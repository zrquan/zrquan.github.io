<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=HandheldFriendly content="True"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta http-equiv=Cache-Control content="no-transform"><meta http-equiv=Cache-Control content="no-siteapp"><meta name=generator content="Hugo 0.139.4"><link rel=apple-touch-icon sizes=180x180 href=/favicon/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon/favicon-16x16.png><link rel=manifest href=/favicon/site.webmanifest><link rel=mask-icon href=/favicon/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>Ghostcat漏洞分析 - zrquan</title>
<meta name=author content="zrquan"><meta name=description content="A minimal Hugo theme with nice theme color."><meta name=keywords content="cve"><meta property="og:title" content="Ghostcat漏洞分析"><meta name=twitter:title content="Ghostcat漏洞分析"><meta property="og:type" content="article"><meta property="og:url" content="https://zrquan.github.io/posts/ghostcat/"><meta property="og:description" content="编号：CNVD-2020-10487/CVE-2020-1938
描述：由于 Tomact AJP 协议的设计缺陷，攻击者可以通过漏洞读取 webapp 目录下的任意文件，或者通过文件包含 getshell。
影响版本：Tomcat 9/8/7/6"><meta name=twitter:description content="编号：CNVD-2020-10487/CVE-2020-1938
描述：由于 Tomact AJP 协议的设计缺陷，攻击者可以通过漏洞读取 webapp 目录下的任意文件，或者通过文件包含 getshell。
影响版本：Tomcat 9/8/7/6"><meta property="og:image" content="https://zrquan.github.io/img/og.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zrquan.github.io/img/og.png"><meta property="article:published_time" content="2021-03-25T00:00:00+08:00"><meta property="article:modified_time" content="2021-03-25T00:00:00+08:00"><style>@media(prefers-color-scheme:dark){body[data-theme=auto] img{filter:brightness(60%)}}body[data-theme=dark] img{filter:brightness(60%)}</style><link rel=stylesheet href=https://zrquan.github.io/assets/css/fuji.min.4c44b7b7f176c7ea2e7d3a85a954d45c0d3e801e81eacbad84c7f9575b51e65dc11b59ff1a372389e8b4e0821d6bbb5a668fe9c3e77af9418acb79126a035a1f.css integrity="sha512-TES3t/F2x+oufTqFqVTUXA0+gB6B6suthMf5V1tR5l3BG1n/Gjcjiei04IIda7taZo/pw+d6+UGKy3kSagNaHw=="></head><body data-theme=auto data-theme-auto=false><script data-cfasync=false>var fujiThemeData=localStorage.getItem("fuji_data-theme");fujiThemeData?fujiThemeData!=="auto"&&document.body.setAttribute("data-theme",fujiThemeData==="dark"?"dark":"light"):localStorage.setItem("fuji_data-theme","auto")</script><header></header><main><div class="container-lg clearfix"><div class="col-12 col-md-9 float-left content"><article><h1 class="post-item post-title"><a href=https://zrquan.github.io/posts/ghostcat/>Ghostcat漏洞分析</a></h1><div class="post-item post-meta"><span><i class="iconfont icon-today-sharp"></i>&nbsp;2021-03-25</span>
<span><i class="iconfont icon-file-tray-sharp"></i>&nbsp;1578 words</span>
<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href=/tags/cve>cve</a>&nbsp;</span></div><div class="post-content markdown-body"><p>编号：CNVD-2020-10487/CVE-2020-1938</p><p>描述：由于 Tomact AJP 协议的设计缺陷，攻击者可以通过漏洞读取 webapp 目录下的任意文件，或者通过文件包含 getshell。</p><p>影响版本：Tomcat 9/8/7/6</p><h2 id=tomcat-connector>Tomcat Connector</h2><p>Connector 是 Tomcat 用来处理外部连接的核心组件，它将底层的 socket 信道封装成
Request 和 Response 两个对象，再交给 Container(servlet 容器)进行处理。</p><p>Connector 的源码在 <code>org.apache.coyote</code> 目录下，默认有两个——分别处理 HTTP 协议和 AJP
协议。</p><figure><img src=/ox-hugo/tomcat.png class="img-zoomable medium-zoom-image" alt=/ox-hugo/tomcat.png></figure><h2 id=apache-jserv-protocol>Apache Jserv Protocol</h2><p>AJP 协议可以简单理解为 HTTP 协议的二进制性能优化版本，它能降低 HTTP 请求的处理成本，因此主要在需要集群、反向代理的场景被使用，默认开放在 8009 端口。</p><p>浏览器无法直接处理 AJP 协议，所以通常用于 Tomcat 和其他 web 服务器的通信，比如
Apache 的 proxy_ajp 模块就可以代理 AJP 协议。</p><figure><img src=/ox-hugo/ajp.png class="img-zoomable medium-zoom-image" alt=/ox-hugo/ajp.png></figure><h2 id=poc>POC</h2><p>部署好环境后，在 github 找个<a href=https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi target=_blank>脚本</a>复现一下漏洞。</p><figure><img src=/ox-hugo/2021-03-23_22-53-01_screenshot.png class="img-zoomable medium-zoom-image" alt=/ox-hugo/2021-03-23_22-53-01_screenshot.png></figure><p>可见通过 AJP 协议请求 <code>/asdf</code> 路径，却读取了 web.xml 文件的内容。</p><p>用 wireshark 看一下 AJP 请求的内容：</p><figure><img src=/ox-hugo/2021-03-23_22-54-13_Snipaste_2021-03-23_18-36-54.png class="img-zoomable medium-zoom-image" alt=/ox-hugo/2021-03-23_22-54-13_Snipaste_2021-03-23_18-36-54.png></figure><p>红框中的三个由用户控制的参数就是导致文件读取的罪魁祸首，下面通过调试 Tomcat 看看怎么处理它们的。</p><h2 id=文件读取>文件读取</h2><p>处理请求的类是 <code>org.apache.coyote.ajp.AbstractAjpProcessor</code> ，进入 prepareRequest
方法，这里是漏洞的入口点，此时的调用栈如下：</p><figure><img src=/ox-hugo/2021-03-23_21-47-36_screenshot.png class="img-zoomable medium-zoom-image" alt=/ox-hugo/2021-03-23_21-47-36_screenshot.png></figure><p>来到关键的 while 语句，在这里对上面提到的三个参数进行设置：</p><figure><img src=/ox-hugo/2021-03-23_23-01-39_screenshot.png class="img-zoomable medium-zoom-image" alt=/ox-hugo/2021-03-23_23-01-39_screenshot.png></figure><p><code>request.setAttribute()</code> 就是简单的 HashMap 赋值操作，循环结束后 attributes 属性如下：</p><figure><img src=/ox-hugo/2021-03-23_23-04-45_screenshot.png class="img-zoomable medium-zoom-image" alt=/ox-hugo/2021-03-23_23-04-45_screenshot.png></figure><p>AJP Connector 封装好 request 对象后，会将其传给 Container 处理。</p><figure><img src=/ox-hugo/2021-03-24_14-13-34_screenshot.png class="img-zoomable medium-zoom-image" alt=/ox-hugo/2021-03-24_14-13-34_screenshot.png></figure><p>Container 即 servlet 容器，相关设置可以在 web.xml 文件找到，下面是默认开启的两个
servlet 容器：</p><pre><code class=language-xml>&lt;servlet&gt;
    &lt;servlet-name&gt;default&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt;
    ...
&lt;/servlet&gt;

&lt;servlet&gt;
    &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.apache.jasper.servlet.JspServlet&lt;/servlet-class&gt;
    ...
&lt;/servlet&gt;

&lt;!-- The mapping for the default servlet --&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;default&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;!-- The mappings for the JSP servlet --&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;
    &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;
    &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre><p>当请求目标的后缀是 jsp 或者 jspx 时由 JspServlet 处理请求，其他情况则由 DefaultServlet
处理。因此为了确保由 DefaultServlet 处理我们的请求，而使用 <code>/asdf</code> 这种大概率不存在的路径。</p><p>代码执行到 DefaultServlet#doGet 方法中：</p><figure><img src=/ox-hugo/2021-03-24_14-46-56_screenshot.png class="img-zoomable medium-zoom-image" alt=/ox-hugo/2021-03-24_14-46-56_screenshot.png></figure><p>一直跟进到 getRelativePath 方法，关键代码如下：</p><figure><img src=/ox-hugo/2021-03-24_14-51-56_screenshot.png class="img-zoomable medium-zoom-image" alt=/ox-hugo/2021-03-24_14-51-56_screenshot.png></figure><p>上图的第一个 if 语句拼接了 path_info 和 servlet_path 参数得到 <code>/WEB-INF/web.xml</code> ，而进入 if 的条件是 request_uri 不为空(不一定要是 <code>/</code>)，这就是 poc 设置该参数的原因。</p><p>获取路径后调用 getResource 方法读取文件：</p><figure><img src=/ox-hugo/2021-03-24_16-01-27_screenshot.png class="img-zoomable medium-zoom-image" alt=/ox-hugo/2021-03-24_16-01-27_screenshot.png></figure><figure><img src=/ox-hugo/2021-03-24_16-02-07_screenshot.png class="img-zoomable medium-zoom-image" alt=/ox-hugo/2021-03-24_16-02-07_screenshot.png></figure><p>红框中的 validate 方法用来检查文件的路径，确保路径以 <code>/</code> 开头，且不会跨越到 webapp
目录以外。代码如下：</p><figure><img src=/ox-hugo/2021-03-24_16-09-10_screenshot.png class="img-zoomable medium-zoom-image" alt=/ox-hugo/2021-03-24_16-09-10_screenshot.png></figure><p>从上图可以看到代码会校验路径是否以 <code>/</code> 开头，且标准化了路径分隔符，但是怎么防止目录穿越呢？在处理路径分隔符的部分调用了 RequestUtil#normalize 方法，我们跟进一下：</p><figure><img src=/ox-hugo/2021-03-24_16-40-44_screenshot.png class="img-zoomable medium-zoom-image" alt=/ox-hugo/2021-03-24_16-40-44_screenshot.png></figure><p>方法开头会替换 windows 系统的 <code>\\</code> ，然后根据情况在开头和末尾加上 <code>/</code> ，在后面执行以下
while 语句：</p><pre><code class=language-java>while (true) {
    int index = normalized.indexOf(&quot;/../&quot;);
    if (index &lt; 0) {
        break;
    }
    if (index == 0) {
        return null;  // Trying to go outside our context
    }
    int index2 = normalized.lastIndexOf('/', index - 1);
    normalized = normalized.substring(0, index2) + normalized.substring(index + 3);
}
</code></pre><p>上述代码会将 <code>/../</code> 和前一个目录名抵消，如果最后 <code>/../</code> 出现在开头，即尝试逃出
webapp 目录，就会返回 null。理解这段代码的关键在于理解 lastIndexOf 方法，它返回第一个参数字符串最后出现的位置，第二个参数是表示位置的整数，可以理解为”只搜索该位置前的内容“。</p><pre><code class=language-java>&quot;aaabbbaaa&quot;.lastIndexOf(&quot;aaa&quot;);     // 6
&quot;aaabbbaaa&quot;.lastIndexOf(&quot;aaa&quot;, 4);  // 0
</code></pre><p>校验完路径后，返回 getResource 方法读取文件资源。</p><figure><img src=/ox-hugo/2021-03-24_16-59-36_screenshot.png class="img-zoomable medium-zoom-image" alt=/ox-hugo/2021-03-24_16-59-36_screenshot.png></figure><h2 id=文件包含>文件包含</h2><p>前面说过 Tomcat 默认的 servlet 容器有两个，当访问的是 jsp 文件时会由 JspServlet
来处理请求。这个处理实际就是解析 jsp 文件，但前提是这个 jsp 文件是存在的，所以首先要想办法上传到 webapp 目录下。</p><p>我们先在 webapp 目录下创建一个 test.jsp：</p><pre><code class=language-jsp>&lt;%Runtime.getRuntime().exec(&quot;calc.exe&quot;);%&gt;
</code></pre><p>修改一下 poc，发送的 AJP 请求如下：</p><figure><img src=/ox-hugo/2021-03-24_18-13-11_screenshot.png class="img-zoomable medium-zoom-image" alt=/ox-hugo/2021-03-24_18-13-11_screenshot.png></figure><p>AJP Connector 的处理和之前类似，我们直接跟进到 JspServlet 类中。这次处理请求的方法是 service，关键代码如下：</p><figure><img src=/ox-hugo/2021-03-24_18-20-01_screenshot.png class="img-zoomable medium-zoom-image" alt=/ox-hugo/2021-03-24_18-20-01_screenshot.png></figure><p>这里拼接 path_info 和 servlet_path 参数得到文件路径，接着调用 serviceJspFile 方法解析目标 jsp 文件。</p><figure><img src=/ox-hugo/2021-03-24_18-23-41_screenshot.png class="img-zoomable medium-zoom-image" alt=/ox-hugo/2021-03-24_18-23-41_screenshot.png></figure><p>所以找到目标文件的关键在于 path_info 和 servlet_path 参数，如果上传的 jsp 文件在 upload
目录下，servlet_path 就要设置为 <code>/upload/</code> ，而 URL 的路径并不重要，只要后缀是 jsp 或者
jspx 即可。</p><p>再跟进一下 serviceJspFile 方法：</p><figure><img src=/ox-hugo/2021-03-24_18-30-29_screenshot.png class="img-zoomable medium-zoom-image" alt=/ox-hugo/2021-03-24_18-30-29_screenshot.png></figure><p>在 JspServletWrapper#service 方法中编译好目标 jsp 文件，获取对应的 servlet 对象，再执行它的 service 方法弹出计算器。</p><figure><img src=/ox-hugo/2021-03-24_18-36-19_screenshot.png class="img-zoomable medium-zoom-image" alt=/ox-hugo/2021-03-24_18-36-19_screenshot.png></figure><h2 id=总结>总结</h2><p>导致文件读取漏洞的是 AJP 请求中的三个用户可控参数：</p><ol><li>javax.servlet.include.request_uri：不为空即可</li><li>javax.servlet.include.path_info：文件名</li><li>javax.servlet.include.servlet_path：根路径</li></ol><p>而当请求资源是 jsp 或 jspx 文件时，由于 JspServlet 类会编译执行目标文件，导致文件包含漏洞，不过前提是能把恶意文件上传到 webapp 目录下。</p></div></article><div class="license markdown-body"><blockquote><p>Unless otherwise noted, the content of this site is licensed under <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a>.</p></blockquote></div><div class=post-comment data-comment=disqus><span class=post-comment-notloaded><i class="iconfont icon-chatbox-ellipses-sharp"></i>&nbsp;Load comments</span><div id=disqus_thread style=display:none></div><script>function loadComment(){var t=document.querySelector(".post-comment"),n=function(){this.page.url="https://zrquan.github.io/posts/ghostcat/",this.page.identifier="ghostcat"},e=document.createElement("script");e.src="https://4shen0ne.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),document.querySelector("#disqus_thread").removeAttribute("style"),(document.body||document.head).appendChild(e),document.querySelector("span.post-comment-notloaded").setAttribute("style","display: none;")}</script></div></div><aside class="col-12 col-md-3 float-left sidebar"><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li><li><a href=/archives/>Archives</a></li><li><a href=/search/>Search</a></li><li><a href=/index.xml>Feed</a></li></ul></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#tomcat-connector>Tomcat Connector</a></li><li><a href=#apache-jserv-protocol>Apache Jserv Protocol</a></li><li><a href=#poc>POC</a></li><li><a href=#文件读取>文件读取</a></li><li><a href=#文件包含>文件包含</a></li><li><a href=#总结>总结</a></li></ul></nav></div></aside></div><div class=btn><div class=btn-menu id=btn-menu><i class="iconfont icon-grid-sharp"></i></div><div class=btn-toggle-mode><i class="iconfont icon-contrast-sharp"></i></div><div class=btn-scroll-top><i class="iconfont icon-chevron-up-circle-sharp"></i></div></div><aside class=sidebar-mobile style=display:none><div class=sidebar-wrapper><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li><li><a href=/archives/>Archives</a></li><li><a href=/search/>Search</a></li><li><a href=/index.xml>Feed</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/zrquan target=_blank><span>GitHub</span></a></li><li><a href=/notes target=_blank><span>Notes</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/tags/ctf/>Ctf</a>
</span><span><a href=/tags/cve/>Cve</a>
</span><span><a href=/tags/deserialize/>Deserialize</a>
</span><span><a href=/tags/emacs/>Emacs</a>
</span><span><a href=/tags/fastjson/>Fastjson</a>
</span><span><a href=/tags/java/>Java</a>
</span><span><a href=/tags/kotlin/>Kotlin</a>
</span><span><a href=/tags/org-mode/>Org-Mode</a>
</span><span><a href=/tags/web/>Web</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#tomcat-connector>Tomcat Connector</a></li><li><a href=#apache-jserv-protocol>Apache Jserv Protocol</a></li><li><a href=#poc>POC</a></li><li><a href=#文件读取>文件读取</a></li><li><a href=#文件包含>文件包含</a></li><li><a href=#总结>总结</a></li></ul></nav></div></div></aside></main><footer><div class="container-lg clearfix"><div class="col-12 footer"><span>&copy; 2021-2024
<a href=https://zrquan.github.io/>zrquan</a>
| <a href=https://github.com/zrquan/zrquan.github.io>Source code</a>
| Powered by <a href=https://github.com/andrew-aiken/hugo-theme-fuji/ target=_blank>Fuji</a> & <a href=https://gohugo.io/ target=_blank>Hugo</a></span></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.0/lazysizes.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-core.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/autoloader/prism-autoloader.min.js></script><script defer src=/assets/js/fuji.min.js></script><script async src=https://unpkg.com/mermaid@8.2.3/dist/mermaid.min.js></script></body></html>